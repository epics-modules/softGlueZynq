<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>softGlueZynq</TITLE>
	<style type="text/css">
	<!--
	blockquote { font-size:smaller;}
	-->
	</style>

</HEAD>
<BODY LANG="en-US" BGCOLOR="#ffffff" DIR="LTR">

<h1><center>The synApps softGlueZynq module (R2-0)</center></h1>
<hr>
<h1>Table of Contents</h1>
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Installation and deployment">Installation and deployment</a></li>
  <li><a href="#User's Manual">User's Manual</a></li>
  <li><a href="#Additional FPGA components">Additional FPGA components</a></li>
  <li><a href="#Miscellaneous configuration">Miscellaneous configuration</a></li>
  <li><a href="#Saving and restoring circuits">Saving and restoring circuits</a></li>
  <li><a href="#Example circuits">Example circuits</a></li>
  <li><a href="#Field wiring">Field wiring</a></li>
  <li><a href="#Custom Interrupt Handlers">Custom Interrupt Handlers</a></li>
  <li><a href="#Implementation">Implementation</a></li>
</ul>
<hr>

<a name="Overview"></a>
<h2><center>Overview</center></h2>

The <a href="http://www.aps.anl.gov/bcda/synApps">synApps</a> softGlueZynq
module enables <a href="http://www.aps.anl.gov/epics">EPICS</a> users and
application developers to construct small, simple, digital electronic circuits,
and to connect those circuits to field wiring, all by writing to EPICS PV's. 
Because the circuits and field connections are defined entirely by EPICS PV's,
they can be <a
href="http://www.aps.anl.gov/bcda/synApps/autosave/autosave.html">autosave</a>d
and restored, saved as text files (for example, as <a
href="https://htmlpreview.github.io/?https://github.com/epics-modules/autosave/blob/R5-7-1/documentation/autoSaveRestore.html#configMenu">configMenu</a> 
files), emailed from one user to another, etc.  softGlueZynq also provides
control over how hardware interrupts are generated by field I/O signals, how
they can be dispatched to cause EPICS processing, and how user-written
interrupt-service routines can be registered for execution in response to a
specified interrupt source.

<blockquote> The name <em>softGlue</em> was intended to suggest <em>glue electronics</em> implemented
by <em>soft</em>ware, where <em>glue electronics</em> means those little bits of digital circuitry needed to
connect two or more larger pieces of digital electronics into a working whole.  <em>softGlueZynq</em>
is a rendition of softGlue for the Xilinx Zynq device, which is the combination of an FPGA and
a processor running Linux.</blockquote>

<P>softGlueZynq does this by loading the Zynq FPGA with a predefined collection of circuit
elements (logic gates, counters, flip-flops, etc.), whose inputs and outputs are connected to
switches controlled by EPICS PV's.  softGlueZynq provides a user interface for controlling those
switches, allowing inputs and outputs to be marked with user-specified names, and connecting or
driving inputs and outputs according to those names.

<P>Here's the underlying idea, schematically:
<P><center><img src="softGlueZynqSchematically.jpg" name="softGlueZynq, schematically"></center>

<P>The box containing <code>X</code>, <code>Y</code>, and <code>Z</code>
represents a softGlue component.  The 15 wires at the botton of the figure
represent the softGlue signal bus.  Output <code>Z</code> is connected to input
<code>X</code>, because their switches select the same softGlue signal bus
line.

<blockquote>

The synchronizing flipflops are not of much interest to an end user; their
purpose is to tell Xilinx routing software how much time it has to get a signal
from the input flipflop to the softGlue component (note: clocked on the falling
edge), from the softGlue component to the output flipflop, and from the output
flipflop through the switches to all input flipflops.  This arrangement sets the
maximum frequency of signals that can be transported on the signal bus to be
half the frequency of the softGlue register clock.  Currently, the softGlue
register clock is 100 MHz.

</blockquote>


<hr>
<h3>Requirements</h3>

<P>To use softGlueZynq, you must have the following hardware and software:

<ul>
<li><h4>Hardware</h4>
<ul>

<li>A  <a href="http://zedboard.org/product/microzed">MicroZed 7020</a>

<li>A carrier card, such as the <a
href="http://zedboard.org/product/microzed-breakout-carrier-card"> MicroZed
Breakout Carrier Card</a>

<li>A MicroSD card.

<li>A MicroSD card writer.

</ul>

<blockquote> softGlueZynq is intended to be useable with any Zynq device, and
will certainly be ported to one or more versions of the PicoZed, but the
FPGA-load files, databases, and MEDM displays supplied in this version are for
the MicroZed 7020.  The first version of softGlueZynq was also useable on the
MicroZed 7010, but that device's FPGA is too small to contain this version,
and it will no longer be supported.</blockquote>

<li><h4>Software</h4>
<ul>

<li>EPICS base, release 3.15.3 or higher.

<li>The EPICS <a href="http://www.aps.anl.gov/epics/modules/soft/asyn">asyn</a> module, version
	4.6 or higher.

<li>The EPICS extension, <a
	href="http://www.aps.anl.gov/epics/extensions/msi/index.php">msi</a>,
	version 1-5 or higher.

	<blockquote>This tool is needed to build some softGlueZynq
	databases.</blockquote>

<li>MEDM, or caQtDM, or CSS-BOY, or the ability to adapt some other display
	manager, or Channel Access client, to implement softGlueZynq's user
	interface.

</ul>
</ul>

	<blockquote> Some of the softGlueZynq databases, displays, and examples
	presume the availability of synApps modules such as calc and busy, but these
	are not needed for any essential feature of softGlueZynq.  You're probably
	going to want autosave, release 5.7 or higher, because it makes loading and
	saving circuits very easy.  SoftGlueZynq includes a 16-input scaler and
	support for the scaler record, which record is in the std module.

	</blockquote>

<p>You do <b>not</b> need to be able to program the Zynq FPGA.  In the default
implementation, the FPGA content is programmed automatically into the module at
IOC-boot time.  A Xilinx .bin file is included with softGlueZynq for this
purpose.  softGlueZynq loads the FPGA on every IOC boot, though it's also
possible to reboot the IOC without affecting a running FPGA.


<blockquote>

If you have a copy of the Xilinx Vivado software, you can load your own custom
FPGA content into the module, and use softGlueZynq to talk to it.  Code and
instructions for reproducing the softGlueZynq Vivado project are in
softGlueZynq/documentation/Vivado.

</blockquote>

<h3>Capabilities</h3>

<P>Here are a few examples of the sorts of things that can be accomplished with
softGlueZynq and EPICS:

<ul>

<li>With no programming at all, softGlueZynq functions simply as a
digital I/O module.

<li>Conditionally send a trigger signal to a detector after every N steps of a
stepper motor.

<li>Conditionally send a trigger signal to a detector after every N(i) steps of
a stepper motor, where N(i) is an array of step-interval numbers.

<li>Gate a detector off during the acceleration and deceleration portions of a
steppermotor's motion.

<li>Send a trigger to a detector precisely 23.003 ms after sending a trigger to
a shutter.

<li>Conditionally trigger the execution of an EPICS record on the change of
state of an external signal.

<li>Implement an extraordinarily smart trigger signal for an oscilloscope.

<li>Implement efficiently a timer useable by EPICS software, with a time
resolution that is much better than the system clock's resolution.  (With this,
you can for example cause an EPICS database to wait for 0.7 ms.)

</ul>


<h4>Implemented circuit elements</h4>

In this version of softGlueZynq, the FPGA is programmed with the following
circuit elements:

<ul>
<li>Four AND gates
<li>Four OR gates
<li>Four noninverting buffers
<li>Two XOR gates
<li>Four D flip-flops
<li>Two 2-input/1-output multiplexers
<li>Two 1-input/2-output demultiplexers
<li>Four 32-bit up counters
<li>Four 32-bit down counters
<li>Four 32-bit divide-by-N counters
<li>Four 32-bit up/down counters
<li>Four gate&delay generators
<li>Two quadrature decoders
<li>One frequency counter

<li>One one-input, 64 channel histogramming scaler on the softGlue signal bus.

<li>One one-input, 64 channel histogramming scaler direct connected to field
I/O.

<li>Two "pixelTrigger" components, configured as an x-ray microscope
data-acquisition system.

<li>One seven-input multichannel scaler.  (This is actually just the
pixelTrigger acquisition system operating in "list" mode.)

<li>36 field-input bits  (24 LVCMOS, 12 LVDS)
<li>24 field-output bits (LVCMOS)
<li>One 10 MHz clock signal (Clock frequencies can be changed at run time.
See <a href="#Miscellaneous configuration">Miscellaneous configuration</a> below.)
<li>One 20 MHz clock signal
<li>One 50 MHz clock signal
<li>One variable frequency clock signal
</ul>

<h4>Analog Processor circuit elements</h4>

<P>In addition to the above listed components, softGlueZynq includes the ability
to handle analog values in much the same way it handles digital values.  This is
accomplished by encoding analog values as bit streams that can be put on the
softGlue signal bus.  This is currently rudimentary: only proof-of-principle
components have been written, and there is no input or output capability.  These
circuit elements are in a separate FPGA-load file ("analogProc"), which also
includes an abbreviated version of the digital components in standard
softGlueZynq.

<ul>
<li>Two two-input sum circuits
<li>Two two-input difference circuits
<li>Two two-input normalized difference ((a-b)/(a+b)) circuits
<li>Four low-pass filters
<li>Two two-input multiply circuits
<li>Two two-input divide circuits
</ul>

<hr>
<a name="Installation and deployment"></a>
<h2><center>Installation and deployment</center></h2>

The simplest way to deploy softGlueZynq is to download and build the module
iocZed, which uses softGlueZynq as a support module, and which contains code to
load and run it on a MicroZed.  iocZed can also include as much or as little of
the rest of synApps as you want.  It's essentially a custom copy of the synApps
xxx module.  As delivered, iocZed is ready for all non-VME dependent synApps
modules, and will build with whatever modules are defined in
<code>synApps/support/configure/RELEASE</code>.  Even if you don't want to use
the MicroZed as a general purpose soft IOC, you're probably going to want
modules like autosave and calc.  If you want to use the included 16 input scaler
with the scaler record, you'll need the std module.

<P>Before I get started, there are a <i>lot</i> of different ways to run Linux,
EPICS, and FPGA code on the MicroZed.  I'm not an expert, but I found a way that
is similar to the way we run vxWorks and soft Linux beamline IOCs at the
Advanced Photon Source, and that's what I'm going to describe.  We build EPICS
and synApps on the read-only file system <code>/APSshare</code>, and build
IOC-application directories on a read-write file system
<code>/net/s<i>N</i>dserv/xorApps/epics/ioc</code>.  You're going to do whatever
you want, of course; I'm just telling you this to make the description more
understandable.


<h3>How to get the software</h3>
softGlueZynq and iocZed are on on GitHub
(<a href="https://github.com/epics-modules/softGlueZynq">softGlueZynq</a>)
(<a href="https://github.com/epics-modules/iocZed">iocZed</a>)

<P>The file <a href="assembleBaseAndSynApps.csh">assembleBaseAndSynApps.csh</a>
is a script you can run to get EPICS base and synApps (including softGlueZynq
and iocZed) from web sources.  Comments at the bottom of the file detail the
edits you'll have to make to get everything to build.

<h3>Building softGlueZynq</h3>

The supported way to build SoftGlueZynq and iocZed is to cross compile.  You
will need a copy of the <a
href="https://www.xilinx.com/products/design-tools/embedded-software/sdk.html">Xilinx
Software Development Kit</a>.  (You'll need to get a license, but the
license is free.)  In the file <a
href="MicroZed_PetaLinux_Prep.txt">MicroZed_PetaLinux_Prep.txt</a> is a
detailed recipe explaining how to configure EPICS base to cross compile for the MicroZed's
linux-arm processor, and how to do some other stuff that you won't need to
do unless you write custom FPGA components.


<ul>

<li>Edit <code>softGlueZynq/configure/RELEASE</code>, to specify the paths
to EPICS_BASE, ASYN, and any other modules you want.

<li>Edit <code>iocZed/configure/RELEASE</code>, to specify the paths to
SUPPORT.

<li>Run <code>make</code> in the top-level directories of softGlueZynq and iocZed, using the
same <code>make</code> executable used to build EPICS base.

<blockquote>The softGlueZynq build will issue a warning that it can't expand all macros
in substitution files.  This is not an error; unexpanded macros are intended
to be defined at boot time.  (Note that version 1-4 of <code>msi</code>
returns an error, which causes the softGlueZynq build to fail, after writing a
database file that contains unexpanded macros.) </blockquote>

</ul>

<h3>Deploying softGlueZynq to an IOC</h3>

<P>A PetaLinux operating system image is included with softGlueZynq.  This
image sets up the Linux directory tree and starts Linux.   PetaLinux is a
memory-resident OS, so nothing you do in the PetaLinux file system will ever
survive a reboot.  For this reason, we put all the EPICS code on an served
file system, have the MicroZed mount that file system, and run EPICS from
there.

<P>Let's say you want to use the IOC prefix "yyy:".  On a workstation, in
a copy of iocZed:

<ul>
<li><code>make distclean</code>
<li><code>changePrefix zzz yyy</code>
<blockquote>changePrefix is a script in the synApps utils directory.  Its
purpose is to customize a copy of the synApps xxx or iocZed module as an
IOC-boot directory.
</blockquote>
<li><code>make</code>

<li><code>chmod a+w iocBoot/iocyyy</code>
<li><code>chmod a+w iocBoot/iocyyy/autosave</code>
<li><code>chmod a+x iocBoot/iocyyy/run</code>
<li>edit <code>start_epics_yyy</code> to set <code>EPICS_APP</code> and
<code>EPICS_APP_ADL_DIR</code>.

<li>edit <code>iocBoot/iocyyy/run</code> to set the environment variable
<code>PATH</code> to the directory that has executables for linux-arm.

<li>edit <code>iocBoot/iocyyy/softGlueZynq.iocsh</code> to select the "system()"
command that will load FPGA content matching your MicroZed version.

<li>In softGlueZynq/documentation/SD_card, find the directory that matches
the MicroZed version you have.  Untar it, edit <code>userConfig</code>
according to instructions in that file.

<blockquote>The strategy for mounting NFS
disks and arranging for directory names to look the same on the MicroZed as
they looked on the workstation that built EPICS software is likely to
change, and it must match Linux-initialization code that will have been
built into <code>BOOT.BIN</code> and <code>image.ub</code>, so I'm not going
to document it here.</blockquote>

<li>Copy <code>userConfig</code>, <code>BOOT.BIN</code> and
<code>image.ub</code> to a MicroSD card, and insert the card in the
MicroZed.

<li>Ensure that the MicroZed's jumpers are set to boot from the MicroSD card:
JP3: 2-3, JP2: 2-3

<li>Power the MicroZed.  If it succeeds in getting an IP address via DHCP, ssh
to root@&lt;IP address&gt;, or to the user account you specified in userConfig.

<li>See if NFS mounts succeeded.  If not, you might be able to do them by
sourcing doMounts.sh.

<li>The alias <code>iocgo</code> should take you to the IOC directory.

<li>Type <code>./run</code> to start the IOC.

</ul>


<h4>Configuring softGlueZynq (editing softGlueZynq.iocsh)</h4>

<P>You shouldn't need to modify anything here, except to select the
<code>system()</code> command that loads the copy of
softGlue_FPGAContent_70x0.bin for the MicroZed model you have.

<h5>User Callable Functions:</h5>
<ul>

<li>
<pre>
initZynqSingleRegisterPort(const char *portName, const char *componentName)
</pre>

<P>Initialize softGlueZynq signal-name support.

<P>Example:

<pre>
initZynqSingleRegisterPort("AXI0", "softGlue_")
# softGlue registers
initZynqSingleRegisterPort("AXI1", "softGlueReg32_")
</pre>

<li>
<pre>
initZynqInterrupts(const char *portName, const char *componentName)
</pre>

<P>Initialize softGlueZynq interrupt support.

<P>Example:

<pre>
initZynqInterrupts("AXI0INT", "softGlue_")
</pre>

</ul>

<h3>Customing softGlueZynq FPGA content and Petalinux code</h3>

<P>The Vivado and Petalinux projects are included in softGlueZynq, in the event
you want to customize either or both of them.  See the file <a
href="MicroZed_PetaLinux_Prep.txt">MicroZed_PetaLinux_Prep.txt</a> in the
softGlueZynq documentation directory, which will lead you to
documentation/Vivado and/or documentation/PetaLinux.

<hr>
<a name="User's Manual"></a>
<h2><center>User's Manual</center></h2>

<P>Most of the essential user-interface information &mdash; how to connect signals, what the display
elements mean, etc. &mdash; is contained in the descriptions of the "User Menu" and "AND" sections
below.  The remaining sections are mostly for completeness, though some circuit elements do require
further explanation, and the counter sections introduce new display elements for registers
containing decimal numbers.

<P>We're going to have a little trouble with the meanings of "input" and "output", because they
imply a viewpoint, and because we're going to be taking three different viewpoints: those of EPICS
records, circuit elements, and field-wiring connectors.  Usually, in EPICS, we think of an output as
something to which an EPICS record can write, but that definition would be awkward here, because it
would eventually require us, for example, to refer to the output of an AND gate as an "input".  You
just can't discuss digital circuitry intelligibly from that viewpoint.

<P>Therefore, in this documentation, "input" and "output" will normally be from the viewpoint of one
of the circuit elements we'll be wiring.  Field I/O will be an exception, because it's most
conveniently discussed from the viewpoint of the field-wiring connector.


	<h3>MEDM user interface</h3>

<ul>

<hr>
<li><P>User Menu
<P><img src="Menu.jpg" name="User Menu">

<P><code>softGlueZynqMenu.adl</code> is the top softGlueZynq display, which serves mostly to call up other
displays.  The menu labelled <code>READ PERIOD</code> specifies the period at which the values of
all signals are sampled for display to the user.  <code>#SIGS IN USE</code>
shows the number of signal names you have defined.


<blockquote>Most softGlueZynq displays are not interrupt driven.  (That would be a disaster, because
inevitably some signals will change state at high frequency.)  So, the states of inputs and outputs
must be sampled periodically, for display to the user.

<P>We've found that it's confusing for users if the poll period is greater than
around 1 second.  We've also found that polling everything at .1 second uses
around 2 percent of the MicroZed's CPU.</blockquote>

<hr>
<li><P>AND
<P><img src="AND.gif" name="AND">

<P> On the left of the AND gate are the inputs, each comprised of a blue "= button", a yellow
text-entry field, a number, and what's intended to look like a red LED.  On the right are
essentially the same things in reverse order, but an output's text-entry field is a different
color.  The text-entry fields are used to connect signals together, and the color difference is
intended to remind you of the only rule governing signal connections: if you connect two or more
outputs together, those outputs won't work.

<blockquote>softGlueZynq outputs are engineered to ensure that you can't break anything by connecting
outputs together, but the circuit won't be useful until you fix the error, because the states of
outputs connected together are undefined.  Currently, softGlueZynq doesn't signal this error by
putting offenders into an alarm state.</blockquote>

<P>The yellow text-entry box controls an input.  You have three options:
<ol>

<b><li>Leave empty.</b><br>

Inputs with empty text-entry boxes default to logic value 1.<P>

<b><li>Enter a string that begins with a number.</b><br>

This directly writes a logic value (optionally, a pulse) to the input.

<P>softGlueZynq will parse everything that looks numberish, and convert to a floating point value.  This
sets the input to a logic value: 0 if the nearest integer to the converted value is zero, 1 if it's
not.

<blockquote>Allowing floats, and extra characters after the number makes it easier to drive softGlueZynq
inputs with calcout records, replies from serial devices, etc.</blockquote>

<P>The strings "0!" and "1!" (possibly followed by other ignored characters)
direct softGlueZynq to write a pair of logic values: "0!" writes "0" followed
immediately by "1"; "1!" writes "1" followed immediately by "0".  The time
interval between writes is system dependent, and not at all guaranteed, but it
should be much smaller than the interval you could achieve from separate
writes.  On an MicroZed 7020, I measure around 3.5 &mu;s.


<b><li>Enter a string that begins with something other than a number.</b><br>

This <em>names</em> the signal, and connects it to all other signals with the same name (or with the
same name followed by '<code>*</code>', as described below).  Case is significant in comparing
signal names.

<blockquote>Note that a "signal", as the word is used in this documentation, is a named connection
between softGlueZynq circuit elements.  It might be more intuitive to think of a "signal" as a wire,
to avoid confusing it with, say, field I/O.</blockquote>

</ol>

<P>If you want to use the inverted value of a signal for input to some component, append
'<code>*</code>' to the signal name.  This doesn't change the signal that the input is
connected to, but just tells softGlueZynq to run the signal through an inverter before applying it
to the input.  Note that output signal names may not end with '<code>*</code>'.

<P>In MEDM, you can use Drag-And-Drop to connect a named signal to some other
signal.  When you drop, MEDM will put the PV name of the signal you dragged
from. When you press &lt;Enter&gt;, softGlueZynq's device support will write the
signal name of the source PV to the destination PV.

<P>In caQtDM, you can select the text of a signal name, and use Copy/Paste
(^C/^V) to copy the signal name from one text-entry box to another.

</ol>

<P>Whatever option you choose, you can define at most fifteen different signal names. When you try
to define the 16th name, softGlueZynq will erase whatever you wrote, and put the record into the
"INVALID" alarm state.  (But note, for example, that <code>reset</code> and <code>reset*</code> are
not different signal names, because the trailing '<code>*</code>' is not regarded as part of the
name; it merely describes how the signal should be used.)

<P>Text-entry boxes for output signals won't accept names beginning with a number, or ending with
'<code>*</code>'.  (softGlueZynq will simply strip the offending characters, and leave the rest.)

<blockquote>A signal name beginning with a number can only be a direct-write command; it cannot connect
things together, because the leading number would be misinterpreted by input-signal-name parsing as a
direct-write command.  Output-signal names ending with '<code>*</code>' are logically sensible, but are
not permitted; this simplifies the implementation of '<code>*</code>' appended to input-signal names.
</blockquote>

<P>A signal's blue "= button" is used to find all other signals to which the signal is connected.
While a signal's "= button" is pressed, input signals connected to it are bordered in green, and output
signals connected to it are bordered in orange.  If you ever see two or more orange borders at
the same time, you have outputs connected together, and your circuit won't work.

<P>The little red and black filled circles (LED's), and the numbers next to them, display the states
of their signals.  These display elements are updated at the period specified in the
<code>softGlueZynqMenu.adl</code> display.  If you want the EPICS PV name corresponding to a signal's
logic value, this is the PV name to use.

<P>For completeness, here's the truth table for an AND gate:
<P><table border>
<tr><th>input1<th>input2<th><th>output
<tr><td>0<td>x<td><td>0
<tr><td>x<td>0<td><td>0
<tr><td>1<td>1<td><td>1
</table>

<blockquote>'x' means "either 0 or 1".</blockquote>


<hr>
<li><P>OR
<P><img src="OR.gif" name="OR">

<P><table border>
<tr><th>input1<th>input2<th><th>output
<tr><td>0<td>0<td><td>0
<tr><td>1<td>x<td><td>1
<tr><td>x<td>1<td><td>1
</table>

<hr>
<li><P>BUFFER
<P><img src="BUFFER.gif" name="BUFFER">

<P>The purpose of the buffer element is to permit EPICS to drive several softGlueZynq inputs
by writing to a single PV, without using up a more valuable circuit element, such as the XOR gate below.

<hr>
<li><P>INVERTING BUFFER
<P><img src="INVERTING_BUFFER.gif" name="BUFFER">

<P>There is no inverting buffer - or any other inverting gate - in softGlueZynq.  Signal inversion is
accomplished by appending '*' to the name of a signal used as as input to any logic element, as
demonstrated above for the buffer element.  Note that '*' appended to the name of an output
signal will be removed.

<hr>
<li><P>XOR
<P><img src="XOR.gif" name="XOR">

<P><table border>
<tr><th>input1<th>input2<th><th>output
<tr><td>0<td>0<td><td>0
<tr><td>0<td>1<td><td>1
<tr><td>1<td>0<td><td>1
<tr><td>1<td>1<td><td>0
</table>

<hr>
<li><P>D FlipFlop
<P><img src="DFF.gif" name="D FlipFlop">

<P>The input signal labelled "&gt;" is the "clock" input.  Unlike other signals, clock inputs are
edge sensitive.  All clock inputs in softGlueZynq act on the rising edge of the input signal.

<P>The open circle ("bubble") in the <code>SET</code> and <code>CLEAR</code> inputs' signal paths indicate
that these signals are inverted before being used.  Thus, applying '0' to the <code>CLEAR</code> input causes
the output to be "cleared" (given the value 0).  <code>SET</code> and <code>CLEAR</code>
are asynchronous: they act immediately, and don't wait for the next clock edge.

<P><table border>
<tr><th>SET<th>CLEAR<th>D<th>&gt; (clock)<th><th>Q
<tr><td>0  <td>0    <td>x<td>x   <td><td>undefined
<tr><td>0  <td>1    <td>x<td>x   <td><td>1
<tr><td>1  <td>0    <td>x<td>x   <td><td>0
<tr><td>1  <td>1    <td>any<td>rising edge<td><td>D<sub>BEFORE</sub> (value D had immediately before the rising edge of the clock signal)
</table>

<hr>
<li><P>2-Input Multiplexer
<P><img src="MUX2.gif" name="2-Input Multiplexer">

<P>When <code>SEL==0</code>, <code>OUT=IN0</code>.  When <code>SEL==1</code>, <code>OUT=IN1</code>.

<hr>
<li><P>2-Output Demultiplexer
<P><img src="DEMUX2.gif" name="2-Output Demultiplexer">

<P>When <code>SEL==0</code>, <code>OUT0=IN</code>, and <code>OUT1</code> is undefined (currently
0).  When <code>SEL==1</code>, <code>OUT1=IN</code>, and <code>OUT0</code> is undefined (currently
0).

<hr>
<li><P>Up Counter (32-bit Counter)
<P><img src="UpCntr.gif" name="32-bit Counter">

<P><code>EN==1</code> enables the clock ("&gt;") input, whose rising edge increments the counter value.
<P><code>CLEAR</code> is asynchronous, and acts whether or not <code>EN==1</code>.

<hr>
<li><P>Down Counter (32-bit Preset Counter)
<P><img src="DnCntr.gif" name="16-bit Preset Counter">

<P><code>EN==1</code> enables the clock (">") input, whose rising edge
decrements the counter value.  When <code>LOAD==1</code> the counter is loaded
immediately with the value applied to the <code>PRESET</code> input (whether or
not <code>EN==1</code>).  While
<code>LOAD==1</code>, the counter does not count down.  While
<code>LOAD==0</code> and <code>EN==1</code>, a rising edge at the clock input
decrements the counter.  When the counter value reaches <code>0</code>, the
output <code>Q</code> goes to <code>1</code>; the next rising edge of the clock
returns <code>Q</code> to <code>0</code> (regardless of the states of
<code>EN</code> and <code>LOAD</code>).

<hr>
<li><P>32-bit Divide By N
<P><img src="DivByN.gif" name="Divide By N">

<P><code>EN==1</code> enables the clock (">") input.  Every <code>N</code>'th
rising edge of the clock drives <code>Q</code> to <code>1</code>.  The next
rising edge returns <code>Q</code> to <code>0</code>.    This behavior produces the correct number of rising edges of
the output signal, but it does not guarantee the same number of falling edges.
Therefore, using an inverted copy of the output to clock downstream electronics
will in some cases have inconsistent results.

When <code>N</code>==<code>1</code>, the divide circuitry is bypassed, and the
clock is connected directly to <code>Q</code>, if <code>EN==1</code>, or is set
to 0 if <code>EN==0</code>.

<P>The <code>RESET</code> signal loads the
counter with <code>N</code>, so that <code>Q</code> will be driven to
<code>1</code> after <code>N</code> rising edges of the clock. 
<code>RESET</code> does not clear the output <code>Q</code>.  If <code>Q</code>
is <code>1</code>, it will be cleared on the first rising edge of the clock.

<P>
<hr>

<li><P>32-bit Up/Down Counter
<P><img src="UpDnCntr.gif" name="Up/Down Counter">

<P><code>EN==1</code> enables the clock (">") input.  <code>CLEAR==1</code> sets
the current count and the output value <code>Q</code> to zero.  When
<code>UP/DOWN==1</code> the counter counts up.  <code>LOAD</code> sets the
current count to <code>PRESET</code>

<P>
<hr>

<li><P>Quadrature Decoder
<P><img src="QuadDec.gif" name="Quadrature Decoder">

<P>This circuit converts a pair of digital quadrature signals <code>A, B</code>
(for example, signals from an encoder) into a pair of <code>STEP, DIR</code>
signals.  <code>A</code> and <code>B</code> are samples on rising edges of the
<code>CLOCK</code> signal.  If either have changed since the last rising edge,
the travel direction implied by the change is output to <code>DIR</code>, and a
pulse is output to <code>STEP</code>.  The pulse width is equal to the period of
the <code>CLOCK</code> signal, and the input frequency may not be greater than
half the clock frequency.

<P>
<hr>

<li><P>Gate&Delay Generator
<P><img src="GateAndDelay.jpg" name="GateAndDelay Generator">

<P>The rising edge of the input signal <code>IN</code> will appear at
<code>OUT</code> after <code>DLY</code> periods of the clock <code>></code>.
If <code>WIDTH</code> is nonzero, it specifies the width in clock periods of
the output pulse.  If  <code>WIDTH==0</code>, the width of the input signal
will be used.

<P>There is a faster version of this component, with 4 ns time resolution,
connected directly to field I/O, and clocked by a dedicated 250 MHz clock. The
fast versions are controlled by the same DLY and WIDTH registers as the normal
(softGlue-bus-connected) versions, but they only use the lower 16 bits of those
registers.  fastGate&Delays 1-4 are hard wired to field inputs FI1-4,
respectively.  By default, the outputs are not connected to field outputs.  You
can change this by selecting "Configure" from the softGlueZynqMenu display.  See
<a href="#Miscellaneous configuration">Miscellaneous configuration</a> below.

<P>
<hr>

<li><P>Frequency Counter
<P><img src="FreqCntr.jpg" name="Frequency Counter">

<P>This component counts the number of rising edges per second
presented to the ">" input.

<P>
<hr>

<li><P>10 MHz internal clock
<P><img src="10MHz_clock.jpg" name="* MHz clock">

<P>10, 20, and 50 MHz clocks, and one clock whose frequency can be varied with
roughly .1 MHz resolution, are available to softGlueZynq circuitry as free
standing outputs.

<blockquote>

All clock frequencies can be changed at run time. See <a href="#Miscellaneous
configuration">Miscellaneous configuration</a> below.

</blockquote>

<hr>
<li><P>Field I/O
<P><img src="Field_IO.jpg" name="Field I/O">

<P>This display allows you to connect field I/O signals to each other and to
softGlueZynq circuits.  Note that a "Field Input Bit" looks like and behaves as
a softGlueZynq <em>output</em>, because what you're actually controlling is the
output of a buffer driven by the field-input signal.  Similarly, a "Field Output
Bit" looks like and behaves as a softGlueZynq <em>input</em>, because you're
actually controlling the input of a buffer that drives the field-output signal.


<P>The signals in this display are the field inputs or outputs connected to 
MicroZed I/O pins.  As currently implemented, softGlueZynq supports 24 inputs
and 24 outputs configured for LVCMOS33, and 12 inputs configured for LVDS.  The
LVCMOS33 outputs are TTL compatible, but the inputs must be limited to around
3.5 V.

<blockquote>You can change the "CONNECTOR&nbsp;#" strings in this display
&mdash; for example, to support a custom signal-breakout module, or to give the
I/O signals application-specific names.  The strings are defined in
<code>softGlueZynqApp/Db/softGlueZynq_FPGAContent.substitutions</code>, as the
macro <code>IOPIN</code> supplied to <code>softGlueZynq_FieldOutput.db</code>
and <code>softGlueZynq_FieldInput.db</code>.</blockquote>

<hr>
<li><P>Field I/O Interrupt support
<P><img src="Field_IO_Int.jpg" name="Field I/O">

<P>Field I/O lines supported by softGlueZynq can generate interrupts on rising
edges.  You control this by setting the "INTERRUPT&nbsp;ENABLE" menu to
"Rising", or "None", respectively. Interrupts are masked by softGlueZynq's
interrupt handler until the current interrupt has been serviced.

<P>When an interrupt occurs, you can have the signal value written to an EPICS
PV, by writing an EPICS link description into the purple box labelled "ON
INTERRUPT, WRITE SIGNAL VALUE VIA THIS LINK".

<P><i>For interrupts that may occur too closely spaced in time for
softGlueZynq's EPICS-record-processing interrupt-response mechanism to handle
reliably, see "Custom Interrupt Handlers", below.</i>

<h4>About EPICS links</h4>

<P>In softGlueZynq displays (and in most other synApps displays), standard EPICS links are displayed as
purple text-entry boxes, in which you describe the link you want to make.  For purposes here, an
EPICS link description is the name of an EPICS PV, followed by one of the following link attributes:

<P><table border>

<tr><td>NPP<td>(default) write value, but do not cause processing.

<tr><td>PP<td>write value and cause processing (if the record containing the PV is "Process
Passive", which means that it's SCAN field has the value "Passive").<br>
You should use this attribute unless you have some reason not to use it.

<tr><td>CA<td>write value and let the record containing the PV decide whether or not to process.

</table>

<blockquote>EPICS will tack on the string " NMS".  This alarm-propagation attribute is not something
end users need to worry about. </blockquote>

<P>For example, to cause a link to write effectively to the top input of the first AND gate
(whose PV name is  <code>zzz:softGlueZynq:AND-1_IN1_Signal</code>, you would write the following
into a purple box:

<pre>zzz:softGlueZynq:AND-1_IN1_Signal PP</pre>

If you only write the PV name, EPICS will supply the link attribute <code>NPP</code>, and your link
will write a value, but the value won't have any effect until the next time the record processes.
(For most PV's in softGlueZynq, the value written by an NPP link won't even be displayed until the
record processes.)

<P><b>Note:</b> if the link writes to a PV in a different IOC, the specified link
attribute will be ignored, and the attribute "CA" will be used instead.

<hr>

<li><P>Convenience
<P><img src="Convenience.gif" name="Convenience">

<P>This display controls two pulse generators implemented in EPICS, with links allowing them to
write to a softGlueZynq input (that is, to a yellow box), and, similarly, two clock generators
implemented in EPICS.  The display also has MEDM related-display callups for two busy records,

<blockquote>The use of EPICS links (the purple boxes in the above display) is described above in
the section "About EPICS links", in the documentation of "Field I/O Interrupt support".</blockquote>

<hr>
<li><P>BusyRecord
<P><img src="BusyRecord.gif" name="Busy Record">

<P>This display controls the value, output link, and forward link of a busy record.  In the
anticipated use with softGlueZynq, one would have some EPICS record outside of softGlueZynq set the busy
record to "Busy" (using a PP link), and arrange for a softGlueZynq interrupt bit (see "Field I/O
Interrupt support", above) to use its EPICS-output link to clear the busy record to "Done" (using a
CA link).

<blockquote>The use of EPICS links (the purple boxes in the above display) is described above in
the section "About EPICS links", in the documentation of "Field I/O Interrupt support".</blockquote>

<blockquote> It's important to <b>set</b> a busy record to "Busy" using a PP link, because the
purpose of a busy record is to represent some external processing as EPICS processing.  This allows
EPICS' execution tracing to signal the completion of the processing.  EPICS only traces processing
started or propagated with a PP link.

<P>It's important to <b>clear</b> a busy record to "Done" with a CA link, because an EPICS PP link
will decline to process any record that is already processing. The busy record is written so that a
CA put will succeed in clearing it and causing its processing to appear done to EPICS.</blockquote>

</ul>
<hr>

<a name="Additional FPGA components"></a>
<h2><center>Additional FPGA components</center></h2>

<P>The following components are not general purpose, but are specific to an
experiment type or a measurement technique.  Components in this category are not
guaranteed to be compatible with previous or future versions of themselves. 
These are custom components, and they will evolve with user requirements.

<ul>

<li><P>16 Input Gated Scaler
<P><img src="SGscaler16.jpg" name="Scaler16 Component">
<img src="scaler16m_more.jpg" name="Scaler Record display">

<P>This is a 16-input gated scaler with the first input dedicated to
determining the dwell time.  Although the scaler16m display has
<code>Gate</code> fields for all inputs, the fields are currently fixed by the
FPGA  content, and by the Epics device support code.  Inputs 2-16 are hardwired
to field inputs 2-16.  Field input 1 is available for use as a gate or clock.

<blockquote>

<P>Note that the scaler as shown here requires the synApps STD module, because
that module defines the EPICS scaler record.  If the STD module is unavailable
or unwanted, you can drive the scaler with softGlueZynq's SGscaler.db database.
But also note that this database is unsupported, and was intended only as a way
for me to learn how to write scalerRecord device support for this scaler
hardware.

<P>The frequency accuracy of softGlueZynq's 10 MHz clock was measured by
comparing it with the 10 MHz output of a Keysight 33600A waveform generator,
which claims few ppm accuracy.  softGlueZynq's 10 MHz clock differed by around
24 ppm on the MicroZed I used for the measurement. I don't know if this is
representative of MicroZeds genrally, or how the frequency varies with
temperature.

</blockquote>

<P>The connections <code>CNT</code>, <code>STOP</code>, <code>CLEAR</code>, and
<code>READ</code>, and the <code>PRESET</code> value are driven by EPICS
scalerRecord device support, if the scaler database is loaded.  The output
<code>Q</code> produces a short positive going pulse when the scaler is done
counting.  The output <code>CNTG</code> goes high when the scaler starts
counting, and goes low when the count is done, either because counter 1 has
reached its preset, or because the user has cleared the scaler record's CNT
field (that is, pressed the "Done" button).

<P>The user is responsible for the following connections: <ol>

<li>connecting a softGlue clock signal to the scaler, and telling the scaler
record the clock frequency, as shown above.

<li>enabling the scaler (the <code>EN</code> input), either with a constant
value, or with some softGlue signal name, as shown above.

<li>connecting the scaler's <code>Q</code> output to field I/O output 16, and
setting that bit's interrupt enable to "Rising", as shown below.  The scaler
record's device support currently is hard coded to use this interrupt source.

</ol>

<P><img src="SGscaler16_fieldIO.jpg" name="Scaler16 Field I/O wiring">

<hr>


<li><P>Histogramming Scaler
<P><img src="HistScal.jpg" name="Histogramming Scaler">
<img src="HistScalerDma.jpg" name="Histogramming Scaler Application">

<P>This is a one-input scaler with 64 time bins.  While <code>EN==1</code>, it
counts pulses presented to <code>DET</code> into one of 64 scalers.  When a
rising edge is presented to <code>SYNC</code>, the first scaler is selected. 
Each time a rising edge is presented to the clock input, the next scaler is
selected.  (Thus, the clock performs as the "channel advance" signal of a
multichannel scaler.) When <code>CLEAR</code> is high, all counters are cleared.

<P>Scaler values are routed via DMA to EPICS, which collects them using an aSub
record, and presents them as an array of counts as a function of the channel
number - time elapsed since the most recent <code>SYNC</code> pulse.

<P>There is a version of this component that can channel advance at up to 250
MHz.  In the high speed version, the SYNC input is connected to the Q output of
fastGate&Delay-3, whose input is hardwired to FI-3; the DET input is connected
to the Q output of fastGate&Delay-4, whose input is hardwired to FI-4; and the
clock input is hardwired to a dedicated clock generator.

<P><img src="fastHistoScaler.jpg" name="fastHistoScaler wiring">
<hr>


<li><P>2D Microscope Data-Acquisition System ("pixelTrigger")
<P><img src="pixelTriggerDemo.jpg" name="pixelTrigger Demo">

<P>This system accepts four interferometer or encoder signals (digital
quadrature), which are the X and Y positions of a microscope lens and sample,
and produces pixel maps of detector data that were acquired in softGlueZynq
counters as the interferometer signals varied.

<P>The user specifies how many interferometer edges are to represent the X and Y
sizes of the pixels.  The circuit subtracts lens and sample positions to yield
the location, on the sample, of the focal spot.  When the focal spot crosses a
pixel boundary, the circuit generates a data-acquisition trigger, which is used
internally and is also available externally.  Internally, the trigger causes the
X,Y coordinates of the pixel, and the current values of seven counters, to be
copied into a FIFO for transmission to EPICS, and it clears the counters to
begin acquisition in the new pixel.  The trigger pulse width is controllable
with the "ACQ TIME" input, in units of the clock period.  This is intended to
limit the trigger rate to a value that external data acquisition electronics (a
camera or a multichannel scaler, perhaps) can handle.

<P>EPICS software maintains seven 32-bit deep pixel maps into which it
histograms counter data according to the pixel coordinates in which those data
were acquired. At the right, above, are 16-bit images generated from the pixel
maps, in which are shown the X/Y trajectory of the focal spot as mechanical
vibrations travelled through the instrument.  (The "instrument," in this case,
is my desktop, on which are interferometer heads and fixed mirrors pretending to
be a microscope.  The mechanical vibrations are just me knocking on the
desktop.)  caQtDM is required for the image display, because MEDM has no 2D
display widget for live data.  

<P>The maximum rate (number of pixel-boundary crossings per second) is around
400,000 pixels/s.  This is determined by the worst case interrupt latency of the
Linux processor, because EPICS must start a DMA transfer to read the FIFO before
it fills up.   <P>Here's a video demonstration of pixelTrigger:

<video width="854" height="480" controls>
  <source src="pixelTriggerSmall.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>
 </ul>

<hr>
<a name="Miscellaneous configuration"></a>
<h2><center>Miscellaneous configuration</center></h2>

<P>There are several features of softGlueZynq that are configurable by the end
user.  Some of these are controlled with the softGlueZynqConfig display shown
below.

<P><img src="Config.jpg" name="softGlueZynqConfig.adl">

<ul>
<li>streamMux

<P>The pixelTrigger, histogramming scaler, and fast histogramming scaler all use
the same data path from the FPGA to EPICS, but only one of them can use it at a
time.


<li>Selected field-I/O points

<P>The fast Gate&Delay generators make sense only if connected directly to field
I/O, because if they were connected to the softGlue signal bus, their inputs and
outputs would be clocked by the softGlue register clock, and this would defeat
the purpose of these components.  Accordingly, the fast Gate&Delay generators
are connected to input pins 1-4, and can be connected to output pins 9-12.

<P>The variable clock (fast histogrammer clock) can be connected directly to
output pin 24.

<li>Clock frequencies

<P>You can change the frequencies of any of the six clocks used in softGlueZynq,
but you need to know what you're doing if the changes are to be useful.  Some
frequencies aren't stable.  You should verify the frequency with the
frequency counter before relying on it.
<ol>

<li>You should probably never change the frequency of the softGlue-register
clock.

<li>The nominally 10, 20, and 50 MHz clocks can be changed to 
frequencies in the range 6-50 MHz, with roughly 5 MHz resolution.

<li>The fast Gate&Delay clock can be changed to a frequency in the
range 6-300 MHz, with roughly 5 MHz resolution.

<li>The fast histoScaler clock can be changed to a frequency in the
range 5-600 MHz, with roughly 0.1 MHz resolution.

</ol>

</ul>


<a name="Saving and restoring circuits"></a>
<h2><center>Saving and restoring circuits</center></h2>
	
	softGlueZynq circuits can be saved and restored using <a
	href="http://www.aps.anl.gov/bcda/synApps/autosave/autosave.html">autosave</a>,
	autosave's <i>configMenu</i> facility, <a
	href="http://www.aps.anl.gov/epics/extensions/burt/index.php">BURT</a>, or
	any channel access client that can read and write PV's.  configMenu is
	particularly handy, because it's driven by EPICS PVs, and because it saves a
	time-stamped backup copy of every file it overwrites.

	<P>Whichever method you use, you may need to clear softGlueZynq signal names
	before loading a circuit, because loading over an existing circuit could
	temporarily exceed the available number of signal names.  (Alternatively,
	you could simply load twice, and be confident that the second load will
	succeed.)

	<h4>Saving and restoring circuits with autosave's configMenu facility</h4>

	<P>Note that the supplied copy of softGlueZynq.iocsh is already configured
	to use configMenu.  The following description is just to document how it's
	done.

	<P><img src="configMenu.jpg" name="configMenu">

	<P>If you have autosave R5-1 or higher, you can use configMenu to save and
	restore circuits.  (autosave R5-7 supports an unlimited number of circuits.)
	Here are the steps needed to implement a menu of softGlueZynq circuits, and
	to give the user a GUI display for saving and restoring them.  (In the
	following, <font color="blue">SG</font> is the name of this instance of
	configMenu.  The files it loads and saves will be named "<font
	color="blue">SG</font>_&lt;<i>config Name</i>&gt;.cfg".  For examples, the
	configMenu instance pictured above has files named "<font
	color="blue">SG</font>_clear.cfg", "<font
	color="blue">SG</font>_encoderTest.cfg", etc.)

	<blockquote> <ol> <li>In the IOC's startup directory, create an autosave
	request file, which I'll call "<font color="blue">SG</font>Menu.req", with
	the following content:

	<P><code>
	file configMenu.req P=$(P),CONFIG=$(CONFIG)<br>
	file softGlueZynq_settings.req  P=$(P),H=$(H)
	</code>

	<P><li>Uncomment the following line in the IOC's copy of
	<code>softGlueZynq.cmd</code>:

	<P><code>dbLoadRecords("$(AUTOSAVE)/asApp/Db/configMenu.db","P=zzz:,CONFIG=<font color="blue">SG</font>")</code>

	<li>Add the following line to <code>st.cmd</code>:

	<P><code>create_manual_set("<font color="blue">SG</font>Menu.req","P=zzz:,CONFIG=<font color="blue">SG</font>")</code>

	<li>Add an MEDM related-display entry to bring up the configMenu.adl display.

	<P><code>
	label="SGMenu"<br>
	name="configMenu.adl"<br>
	args="P=zzz:,CONFIG=<font color="blue">SG</font>"
	</code>

	</ol>
	</blockquote>

	<P>softGlueZynq includes configMenu files (*.cfg) for standard example circuits
	in the iocBoot/iocsoftGlueZynq directory.  In actual use, these .cfg files would
	be placed in your application's iocBoot/ioczzz/autosave directory.  For more
	information on configMenu, see the autosave documentation.

<hr>
<a name="Example circuits"></a>
<h2><center>Example circuits</center></h2>

<P>The following circuits have been tested and saved as configMenu .cfg files, 
as described above (see <i>Saving and Restoring Circuits</i>).  The .cfg files
are in iocBoot/iocsoftGlueZynq.

		<ol>
		<li><h4>Motor-pulse gate </h4>

		Positive-going pulses can be gated with an AND gate, by applying the signal to
		one input of the AND gate, and setting the other input to 0(1) to deny(allow)
		passage through the gate.

		<P>Negative-going pulses can be gated with an OR gate, by applying the signal
		to one input of the OR gate, and setting the other input to 0(1) to
		allow(deny) passage through the gate.

		<li><h4>Gated scaler</h4> <P><i><code>gatedScaler.cfg</code></i>

		<P>This circuit implements four counter channels, a time base to control
		counting time, an overall gate, and additional circuitry to control
		starting,  stopping, and processing of the count-value records.  Note
		that the scaler is controlled by a busy record from the softGlueZynq
		convenience database, so that client software can discover when counting
		is finished in the standard EPICS way.  See
		<a href="gatedScaler.txt">gatedScaler.txt</a> for more details.


		<P><img src="gatedScaler.jpg" name="gatedScaler">

		<li><h4>Four independent start-time/stop-time pulses</h4>
		<P><code>fourPulses.cfg</code>

		<P>This circuit produces four separate pulse signals, which start at
		specified start-delay times after (the falling edge of) an initial start
		pulse, and which last for specified pulse-length times.  It uses four
		DnCntr's to implement the start-delay times, and four DivByN's to
		implement the pulse-length times.  Times are specified as multiples of
		the (100 ns) clock period (<code>PRESET</code> for the DnCntr's;
		<code>N</code> for the DivByN's), and these numbers must be greater than
		or equal to 1.  The pulse sequence starts on the falling edge of the
		signal <code>BUF-1</code>, written by a periodically scanned EPICS
		record (one of the softGlueZynq convenience clocks).  One spare signal name
		is available, however, so the pulse sequence could also be started by an
		external signal.

		<P><img src="fourPulses.jpg" name="fourPulses">

		<li><h4>Motor-pulse accel/decel gate</h4>
		
		<P><code>accelDecelGate.cfg</code></i>  <br>
	
		<P>If you know the number of steps a stepper motor will move during its acceleration time, you
		can easily arrange to deliver motor pulses to some external circuit only while the motor is
		moving at constant speed.  For a stepper motor controlled by the motor record, the number of
		acceleration/deceleration steps, <code>N<sub>a</sub></code>, can be calculated with the following
		formula:

		<ul>
		<p><code>N<sub>a</sub> = ((VBAS+VELO)/2)*ACCL/MRES</code>
		</ul>

		<P>where, <code>VBAS</code>, <code>VELO</code>, <code>ACCL</code>, and <code>MRES</code> are
		motorRecord fields.
		
		<P>The number of constant-speed steps, <code>N<sub>c</sub></code>, is then

		<ul>
		<P><code>N<sub>c</sub> = ((VAL<sub>end</sub> - VAL<sub>start</sub>)/MRES) -
		2*N<sub>a</sub></code>
		</ul>

		<P>where <code>VAL<sub>end</sub></code> and <code>VAL<sub>start</sub></code> are the final
		and initial values of the motorRecord <code>VAL</code> field.

		<P>The following circuit accepts negative-going motor pulses at input signal 1, gates out
		the first 11 (the value of <code>DnCntr-1_PRESET</code>), and from then on sends motor
		pulses to output pin 17 until a total of 31 (the value of <code>DnCntr-2_PRESET</code>) have
		been sent.  The circuit is reset by writing "1!" (positive-going pulse) to the input of BUF-1.

		<P>The circuit includes some diagnostics, and a mechanism for testing:
			<ul>

			<li><code>UpCntr-1</code> counts all motor pulses; <code>UpCntr-2</code> counts gated
			motor pulses.  Both counters are reset by the same signal that resets the gate circuit.

			<li>A manual reset is implemented using BUF-1.  Writing "1!" to the input of BUF-1,
			as shown, causes a short positive-going pulse to be applied to it, and thus to its output,
			the signal named "reset".

		<P><img src="accelDecelGate.jpg" name="accelDecelGate">

		<P>Down counter <code>DnCntr-1</code>, and flipflop <code>DFF-1</code>, together produce a gate
		signal that is 0 after a reset, and that goes to 1 after <code>DnCntr-1_PRESET</code> motor
		pulses.  Down counter <code>DnCntr-2</code>, and flipflop <code>DFF-2</code>, together produce a
		gate signal that is 1 after a reset, and that goes to 0 after <code>DnCntr-2_PRESET</code> motor
		pulses.  We load the number of acceleration steps into <code>DnCntr-1_PRESET</code>, and the
		number of acceleration steps plus constant-speed steps into <code>DnCntr-2_PRESET</code>.

		<P><code>AND-1</code> combines the gate signals produced above into a signal that is 1 while
		the motor is moving at constant speed.

		<P><code>AND-2</code> gates the negative-going motor pulses, using what
		was described in the "Motor-pulse gate" example as a
		positive-going-pulse gate, by inverting the "motor" signal before
		applying it to the gate.

		<P>Note that the down counters are clocked by (rising edges of) "motor", to produce the
		signal used to gate "motor<code>*</code>".  This choice avoids a race condition between simultaneous
		rising edges of "gateOut" and "motor".  (This circuit gates negative-going motor pulses, so
		another way to make the point is to say that the trailing edge of a motor pulse is used to
		produce a gate that will be ready in plenty of time for the leading edge of the next motor
		pulse.)

		<P>Calculations for the circuit are shown in the following screen capture of a transform
		record.

		<P><img src="accelDecelGateCalc.gif" name="accelDecelGateCalc">
		</ol>

<P>For more softGlue-circuit examples, see
<a
href="https://subversion.xray.aps.anl.gov/admin_bcdaext/softGlue_examples">softGlue_examples</a>
Currently, the following circuits are documented:
<ul>
<li>Programmable pulse train
<li>Gated scaler
<li>Pulse burst
<li>Delay generator
<li>Motor accel/decel pulse gate
<li>Debouncer
</ul>


<hr>
<a name="Field wiring"></a>
<h2><center>Field wiring</center></h2>

See the file <a
	href="MicroZedPinout_TTL.txt">MicroZedPinout_TTL.txt</a>


<hr>
<a name="Custom Interrupt Handlers"></a>
<h2><center>Custom Interrupt Handlers</center></h2>

softGlueZynq's normal interrupt-response mechanism allows you to specify the
execution of an EPICS output link, which will write to and possibly process a
specified EPICS record, whenever an enabled interrupt occurs.  This mechanism is
unreliable for interrupts that are spaced in time by less than a few
milliseconds, because the EPICS processing is dispatched through message queues,
and requires several task switches before the target record gets processed.

<P>For interrupts that may occur more closly spaced in time, you can write a
custom interrupt-handler routine, and tell softGlue to call it whenever an
enabled interrupt occurs.  There is an example in the softGlueApp/src
directory:  sampleCustomInterruptHandler.c.

<P>sampleCustomInterruptHandler.c contains two functions:
<dl>

<dt><code>sampleCustomInterruptPrepare()</code>

<dd>This function gathers some information for use by
<code>sampleCustomInterruptRoutine()</code>, and tells softGlue to call
<code>sampleCustomInterruptRoutine()</code> from its interrupt-service routine
when a specified interrupt occurs.  The interrupt is specified by
<code>risingMask</code>, and <code>fallingMask</code>, which specify one or more
bits.  Currently, <code>fallingMask</code> is ignored.  The address of
BUFFER-4_IN is stored for use by sampleCustomInterruptRoutine().

<dt><code>sampleCustomInterruptRoutine()</code>

<dd>This function writes a pulse to the softGlue signal register whose address
was calculated by <code>sampleCustomInterruptPrepare()</code>.

</dl>

<P>Other files in softGlueApp/src that help implement
sampleCustomInterruptHandler are <code>Makefile</code>, which builds it, and
<code>softGlueSupport.dbd</code>, which contains the line
<code>registrar(sampleCustomInterruptRegistrar)</code>.

<h4>Interrupt-response time</h4> <P>On a microZed 7020, interrupt-response time
was measured using  sampleCustomInterruptRoutine(), and routing the interrupt
response (BUFFER_4_OUT) to the clock input of a counter, and to an output pin. 
The signal that generated the interrupt was also routed to the clock input of a
counter.  On a scope, it's clear that interrupt-response times cluster around 30
microseconds, but there are outliers.  These were characterized by comparing
counter values after many interrupts had been generated and serviced.

<P>In initial tests, it was found that autosave reliably caused generated
interrupts to be missed whenever it wrote the auto_settings file.  To measure
baseline performance, autosave was disabled.

<P>Here are the results (with autosave disabled):
<pre>
	At  1 kHz, no misses in 10 minutes.
	At  2 kHz, no misses in 10 minutes.
	At  5 kHz, 27 misses in 10 minutes
	At 10 kHz, 22 misses in 1 minute.
	At 20 kHz, 2800 misses in 1 minute.
</pre>






<hr>
<a name="Implementation"></a>
<h2><center>Implementation</center></h2>

<P>Here's what a component looks like in the Xilinx Vivado block diagram:
<P><center><img src="inVivado.jpg" name="Vivado block diagram"></center>

<P>The switches, synchronizing flipflops, and softGlue signal bus lines are all
contained in the big blue box, which Xilinx calls an "AXI4 peripheral."  To us,
this means that it contains registers we can read and write from EPICS.  Each
switch is controlled by an eight bit register, as detailed later in the section
"softGlueZynq register component."

<P>Here is what that component looks like in the EPICS substitutions file
<code>softGlue_FPGAContent.substitutions</code>:

<blockquote>
<pre>
file "softGlue_Input.db"
{
pattern {SIG     ADDR}
...
{DFF-1_D        124}
{DFF-1_CLOCK    125}
{DFF-1_SET      126}
{DFF-1_CLEAR    127}
...
}

file "softGlue_Output.db"
{
pattern {SIG  ADDR}
...
{DFF-1_OUT    14}
...
}

</pre>
</blockquote>

Here is the corresponding MEDM display:
<P><img src="DFF.gif" name="D FlipFlop">

<P>It's easy to add custom components to softGlue, and get them hooked up to
EPICS PVs.  Making an MEDM display is also easy, because softGlue displays are
hierarchical, and nearly all the work has already been done.  You just choose
the existing display that resembles what you want, add or delete inputs and
outputs, and rename stuff.  Thus, softGlueZynq is useful not only for making
circuits by wiring existing components; it's also infrastructure to support
custom application-specific electronics.

<P>For completeness, here's what that flipflop looks like in Verilog:

<blockquote>
<pre>
module flipflop (
	input wire regClk, D, Clk, Set, Clear,
	output reg Q
);
	reg [1:0] rClk;
	
	// detect rising edges
	always @(negedge regClk) begin
		rClk <= {rClk[0], Clk};
	end

	always @(negedge regClk) begin
		if (~Set)
			Q <= 1;
		else if (~Clear)
			Q <= 0;
		else if (rClk==2'b01)
			Q <= D;
	end
endmodule
</pre>
</blockquote>

This Verilog file contains all of the information Vivado needs to make
a component that can be added to the softGlueZynq block diagram.  There is a
recipe, in softGlueZynq/documentation/Vivado/README, for doing that.

	<h3>FPGA-content files</h3>

	softGlueZynq contains FPGA-content files, only one of which can be loaded at a
time.

<P><dl>
<dt>softGlue_FPGAContent_7020.bin
<dd>This file contains standard softGlueZynq for a Zynq 7020 chip.


</dl>

	<h3>Database files</h3>

<dl>

<dt>softGlueZynq_FPGAContent.substitutions

<dd>This substitutions file is run through <code>msi</code> at build time to
produce the database file <code>softGlueZynq_FPGAContent.db</code>.  The
database file loads records matching most of the FPGA content that is loaded at
cold-boot time from <code>softGlue_FPGAContent_7020.bin</code>.<P>


<dt>softGlueZynq_Input.db<br>
softGlueZynq_Output.db

<dd>These databases each support a single softGlueZynq circuit-element I/O
bit.<P>

<dt>softGlueZynq_FieldInput.db<br>
softGlueZynq_FieldOutput.db

<dd>These databases each support a single field I/O bit.<P>

<dt>softGlueZynq_InRegister.db

<dd>This database supports reads from a 32-bit register.<P>

<dt>softGlueZynq_IntBit.db

<dd>This database supports a single input bit, with an interrupt-driven bi
record to read the bit value, and a forward linked bo record to write that value
to some user specified EPICS PV.<P>

<dt>softGlueZynq_IntEdge.db

<dd>This database controls the interrupt-enable mask for a single input bit.<P>

<dt>softGlueZynq_Register.db

<dd>This database supports writes to a 32-bit register, such as the "N" value
for a divide-by-N circuit element.<P>

<dt>softGlueZynq_SignalShow.db

<dd>This database implements part of softGlueZynq's mechanism for showing users
which signals are connected together.  When a user presses a signal's "=
button", the signal's name is written to a PV in this database, against which PV
all softGlueZynq signals compare their own signal names, to determine whether or
not to display their "connected" boxes.<P>

<dt>softGlueZynq_convenience.db

<dd>This database contains two busy records by which softGlueZynq can signal
completion to EPICS, two software pulse generators, and two software clock
generators.<P>

</dl>



	<h3>Autosave-request files</h3>

<dl>
<dt>softGlueZynq_FPGAContent_settings.req<br>
softGlueZynq_FPGAInt_settings.req<br>
softGlueZynq_SignalShow_settings.req<br>
softGlueZynq_convenience_settings.req<br>

<dd>These autosave request files correspond with similarly named database or
substitutions files, and take the same macro definitions.<P>

<dt>softGlueZynq_settings.req

<dd>This autosave-request file <i>includes</i>
softGlueZynq_SignalShow_settings.req, softGlueZynq_FPGAContent_settings.req,
softGlueZynq_FPGAInt_settings.req, and softGlueZynq_convenience_settings.req. 
For standard softGlueZynq, this is the only autosave-request file an IOC
needs.<P>

</dl>

	<h3>Display files (MEDM, CSS-BOY, and caQtDM)</h3>

	There are too many display files to describe individually, and many are
	similar, so I'll just describe classes of display files, and the overall
	implementation strategy.  Displays whose names begin with "softGlueZynq_"
	support individual circuit elements.  Displays whose names are of the form
	"softGlueXxx" (no underscore after "softGlueZynq") support collections of
	circuit elements, either by implementing menus for calling up other
	displays, or by including several "softGlueZynq_" displays.  ("Include", in this
	context, means specified as a "Composite File", with macro arguments, in the
	definition of an MEDM grouped item, or specified as a "linkgroup" in
	CSS-BOY.)

	<P>In the rest of this display-file documentation, I'll give MEDM examples.
	For CSS-BOY examples, just substitute ".opi" for ".adl".  For caQtDM,
	substitute ".ui".

	<P>The display of a softGlueZynq circuit element is built in layers, from
	instances of softGlueZynq_Input.adl and softGlueZynq_Output.adl, which are
	<i>included</i> in softGlueZynq_&lt;element name&gt;_bare.adl, which in turn is
	included in one of the user displays (for example, softGlueZynqAll.adl,
	softGlueZynq_AND.adl, etc.).

	<P><dl>
	<dt>softGlueZynqMenu.adl<br>
	softGlueZynqTop.adl

	<dd><code>softGlueZynqMenu.adl</code> contains related-display menus for
	everything in softGlueZynq. <code>softGlueZynqTop.adl</code> is an example
	of how <code>softGlueZynqMenu.adl</code> can be called up.

	<dt>softGlueZynq_Input.adl<br>
	softGlueZynq_Output.adl
	
	<dd>These displays support a <i>single 16-bit register component</i> (see "Driver", below) in the
	FPGA, and most softGlueZynq circuit-element displays include several instances of these displays.  For
	example, softGlueZynq_AND_bare.adl includes two instances of softGlueZynq_Input.adl, and one instance of
	softGlueZynq_Output.adl.

	<dt>softGlueZynq_*.adl<br>
	softGlueZynq_*_bare.adl, where * is one of AND, BUFFER, DEMUX2, DFF, DivByN, DnCntr, MUX2, MUX4, OR, Shift32, UpCntr, XOR

	<dd>These files each support a single circuit element, such as an AND gate.  The "_bare.adl"
	displays are intended to be included in some other display.

	<dt>softGlueZynq_Field*.adl<br>
	softGlueZynq_Field*_bare.adl, where * is one of FieldInput, FieldOutput, IntBit.    The "_bare.adl"
	displays are intended to be included in some other display.

	<dd>These files support a single field-I/O bit, or the interrupt control and dispatch records
	associated with a field-I/O bit.

	</dl>


<h4> softGlueZynq register component</h4>

Most of softGlueZynq is implemented with registers implemented in the FPGA
controlling components connecting to standard digital circuitry, such as AND
gates, counters, etc., through interface circuitry of the following three types:

<P><dl>

<dt>Input

<dd>An input is essentially a 16-input multiplexer controlled by a register that softGlueZynq
can write to and read from.  Inputs 1-15 of all input multiplexers are connected together to form a
15-line bus, so that all inputs with the same multiplexer address are connected together.

<P>Input 0 of the multiplexer is special: it connects to the "U" bit of the signal's control
register, instead of to a bus line, and is the means by which softGlueZynq implements direct user
control of the signal value.  When the user writes "0" or "1" as a signal name, softGlueZynq sets the
multiplexer address to zero, and sets the "U" bit to 0 or 1.

<P>A second register bit, "N", controls whether or not the multiplexer output is routed through an
inverter before connecting to the payload digital circuit element input; this bit is the means by
which softGlueZynq implements names like "reset*", which connects the input to an inverted copy of the
signal, "reset".  The invert bit could be, but currently is not, used with the "U" bit.

<P><table border>
<tr><td>bit:<td>&nbsp;7<td>&nbsp;6<td>&nbsp;5<td>&nbsp;4<td>&nbsp;3<td>&nbsp;2<td>&nbsp;1<td>&nbsp;0
<tr><td>function:<td>N<td>R<td>U<td>&nbsp;r<td>A<sub>3</sub><td>A<sub>2</sub><td>A<sub>1</sub><td>A<sub>0</sub>
</table>

<P>where
<P><table border>
<tr><td>N<td>invert-signal bit
<tr><td>R<td>read bit
<tr><td>U<td>user-write bit
<tr><td>A<sub>n</sub><td>bus-line address bit
<tr><td>r<td>reserved for future use
</table>

<dt>Output

<dd>An output is a signal routed via a demultiplexer to any of 15 bus lines.  No connection is made
to the demultiplexer output selected by the address 0; this address is used to implement unconnected
output signals.

<P><table border>
<tr><td>bit:<td>&nbsp;7<td>&nbsp;6<td>&nbsp;5<td>&nbsp;4<td>&nbsp;3<td>&nbsp;2<td>&nbsp;1<td>&nbsp;0
<tr><td>function:<td>&nbsp;&nbsp;<td>R<td>&nbsp;&nbsp;<td>&nbsp;r<td>A<sub>3</sub><td>A<sub>2</sub><td>A<sub>1</sub><td>A<sub>0</sub>
</table>
<P>where R and A<sub>n</sub> are as defined above for the input register.

<dt>32-bit register<dd>integer value written by EPICS to a parameter register
with a fixed connection to a specific device instance.


</dl>

<hr>
<ADDRESS STYLE="text-align: left">Suggestions and Comments to: <br>
<A HREF="mailto:mooney@aps.anl.gov">
Tim Mooney </A>: (mooney@aps.anl.gov) 
</ADDRESS>
</BODY>
</HTML>
