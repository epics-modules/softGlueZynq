<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>softGlue</TITLE>
	<style type="text/css">
	<!--
	blockquote { font-size:smaller;}
	-->
	</style>

</HEAD>
<BODY LANG="en-US" BGCOLOR="#ffffff" DIR="LTR">

<h1><center>The synApps softGlue module (v2.7)</center></h1>
<hr>
<h1>Table of Contents</h1>
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Installation and deployment">Installation and deployment</a></li>
  <li><a href="#User's Manual">User's Manual</a></li>
  <li><a href="#Add-on FPGA components">Add-on FPGA components</a></li>
  <li><a href="#Saving and restoring circuits">Saving and restoring circuits</a></li>
  <li><a href="#Example circuits">Example circuits</a></li>
  <li><a href="#Field wiring">Field wiring</a></li>
  <li><a href="#Custom Interrupt Handlers">Custom Interrupt Handlers</a></li>
  <li><a href="#Implementation">Implementation</a></li>
</ul>
<hr>

<a name="Overview"></a>
<h2><center>Overview</center></h2>

The <a href="http://www.aps.anl.gov/bcda/synApps">synApps</a>
softGlue module enables <a href="http://www.aps.anl.gov/epics">EPICS</a> users
and application developers to construct small, simple, digital electronic
circuits, and to connect those circuits to field wiring, all by writing to EPICS
PV's.  Because the circuits and field connections are defined entirely by EPICS
PV's, they can be <a
href="http://www.aps.anl.gov/bcda/synApps/autosave/autosave.html">autosave</a>d
and restored, saved as text files (for example, as <a
href="http://www.aps.anl.gov/epics/extensions/burt/index.php">BURT</a> snapshot
files), emailed from one user to another, etc.  softGlue also provides safe (throttled) user
control over how hardware interrupts are generated by field I/O signals, and how
they are dispatched to cause EPICS processing.

<blockquote> The name <em>softGlue</em> is intended to suggest <em>glue electronics</em> implemented
by <em>soft</em>ware, where <em>glue electronics</em> means those little bits of digital circuitry needed to
connect two or more larger pieces of digital electronics into a working whole.</blockquote>

<P>softGlue does this by loading an IndustryPack FPGA-based digital I/O module with a predefined
collection of circuit elements (logic gates, counters, flip-flops, etc.), whose inputs and outputs
are connected to switches controlled by EPICS PV's.  softGlue provides a user interface for
controlling those switches, allowing inputs and outputs to be marked with user-specified names,
and connecting or driving inputs and outputs according to those names.

<P>Here's the underlying idea, schematically:
<P><center><img src="softGlueSchematically.jpg" name="SoftGlue, schematically"></center>


<h3>Requirements</h3>

<P>To use softGlue, you must have the following hardware and software:

<ul>
<li><h4>Hardware</h4>
<ul>

<li>An IndustryPack (IP) carrier board supported by the EPICS ipac module.

<li>An Acromag IP-EP20x FPGA IP module.

</ul>

<blockquote> SoftGlue 2.x is intended to be useable with any IP_EP200-series
module, but the databases and MEDM displays supplied in this version are for the
IP_EP201, and other modules in the series have not yet been tested.  The
differences between modules are in the numbers of I/O bits, and the
pinout.</blockquote>

<li><h4>Software</h4>
<ul>

<li>The EPICS <a href="http://www.aps.anl.gov/epics/modules/soft/asyn">asyn</a> module, version
	4.6 or higher.

<li>The EPICS <a href="https://svn.aps.anl.gov/trac/epics/ipac">ipac</a> module, version 2.11
	or higher.

	<blockquote>To use an earlier version, see "Building softGlue" below.
	</blockquote>

<li>The EPICS extension, <a href="http://www.aps.anl.gov/epics/extensions/msi/index.php">msi</a>,
    version 1-5 or higher.
	
	<blockquote>This tool is needed to build some softGlue databases.</blockquote>

<li>MEDM, or CSS-BOY, or caQtDM, or the ability to adapt some other display
	manager or Channel Access client to implement softGlue's user interface.

</ul>
</ul>

	<blockquote>SoftGlue versions 2.1 and lower also require the EPICS <a
	href="http://www.aps.anl.gov/bcda/synApps/calc/calc.html">calc</a> module. 
	Some of the databases, displays, and examples presume the availability of
	other synApps modules, such as calc, busy, and std, but these are not needed
	for any essential feature of softGlue.

	</blockquote>

<p>You do <b>not</b> need to be able to program the IP-EP20x module.  In the default implementation,
the FPGA content is programmed automatically into the module at IOC-boot time, via the IP bus.  A
text file is included with softGlue for this purpose.  softGlue attempts to load the FPGA on every
IOC boot, but the load succeeds only on a cold boot.  A warm boot leaves previously loaded content
in place.


<blockquote>

If you have a copy of Altera's "Quartus" software, you can load your own custom FPGA content into
the module, and use softGlue to talk to it.  softGlue was designed with this use in mind, though we
don't yet have documentation on how it's done.

</blockquote>

<h3>Capabilities</h3>

<P>Here are a few examples of the sorts of things that can be accomplished with
softGlue and EPICS: 

<ul>

<li>With no programming at all, softGlue functions simply as good support for a 48-bit digital I/O module.

<li>Conditionally send a trigger signal to a detector after every N steps of a stepper motor.

<li>Conditionally send a trigger signal to a detector after every N(i) steps of
a stepper motor, where N(i) is an array of step-interval numbers.

<li>Gate a detector off during the acceleration and deceleration portions of a
steppermotor's motion.

<li>Send a trigger to a detector precisely 23 ms after sending a trigger to a shutter.

<li>Conditionally trigger the execution of an EPICS record on the change of state
of an external signal.

<li>Implement an extraordinarily smart trigger signal for an oscilloscope.

<li>Implement efficiently a timer useable by EPICS software, with a time resolution that is
much better than the system clock's resolution.  (With this, you can for example cause an
EPICS database to wait for 0.7 ms.)

</ul>


<h4>Implemented circuit elements</h4>

In this version of softGlue, the FPGA is programmed with the following circuit
elements:

<ul>
<li>Four AND gates
<li>Four OR gates
<li>Four noninverting buffers
<li>Two XOR gates
<li>Four D flip-flops
<li>Two 2-input/1-output multiplexers
<li>Two 1-input/2-output demultiplexers
<li>Four 32-bit counters
<li>Four 32-bit preset counters
<li>Four 32-bit divide-by-N circuits
<li>48 field-input bits
<li>48 field-output bits
<li>One 8MHz clock signal
</ul>

<blockquote>Earlier versions of softGlue implented many components with both
inverting and noninverting outputs.  Beginning with 2.0, signal inversion is
accomplished by appending '<code>*</code>' to a signal name, and this removes
the need to implement inverted outputs.  Unfortunately, this means that softGlue
PV values saved from an earlier version of softGlue will not restore correctly
in softGlue 2.x.  The functionality of the circuit will certainly still be
achievable, but signal names have changed, and the circuit will have to be
re-engineered.</blockquote>

<P>In addition to the above listed components, softGlue 2.x includes shift
registers, up/down counters, and quadrature decoders in separate FPGA packages. 
Currently, we don't have the capability of loading more than one FPGA-content
file (the IP-EP20x FPGA does not support this), but we can combine the standard
softGlue FPGA content with any one add-on package, and load that.  Thus, there's
a clear path to standard softGlue plus application-specific FPGA content and
support. softGlue databases and MEDM-display files are engineered to simplify
the development of support for add-on packages.


<hr>
<a name="Installation and deployment"></a>
<h2><center>Installation and deployment</center></h2>

	softGlue is a synApps module, so if you've used any other synApps module, you probably
	already know how to install and deploy it.  The important thing is that softGlue is pure
	support: you are not expected to run an IOC directly with it, but instead to draw from
	the module into your own IOC application.
	
	<blockquote>Unlike most other synApps modules, however,
	softGlue publishes the text files needed to boot an IOC in its <code>db</code> directory
	(as an EPICS module really should, I suppose &mdash; most synApps modules are nonstandard in
	this respect), rather than in the <code>softGlueApp/Db</code> directory.</blockquote>

	<h3>How to get the software</h3>
	softGlue is available as part of synApps 5.5 and higher, as a tar file from
	the <a href="http://www.aps.anl.gov/bcda/synApps/softGlue/softGlue.html">softGlue web page</a>,
	or directly from the <a href="https://subversion.xray.aps.anl.gov/synApps">synApps subversion repository</a>.
	To export version 2.2 from the repository, for example, run the following command:

	<P><code>
	svn export https://subversion.xray.aps.anl.gov/synApps/softGlue/tags/R2-2 softGlue-2-2
	</code>

	<h3>Building softGlue</h3>

	<ul>

	<li>Edit <code>softGlue/configure/RELEASE</code>, to specify the paths to EPICS_BASE, ASYN, and
	IPAC.

	<li>If you're using a version of IPAC older than 2.11, edit
	<code>softGlueApp/src/drvIP_EP201.c</code> to change the definition of the macro,
	<code>DO_IPMODULE_CHECK</code>, like so: <pre>#define DO_IPMODULE_CHECK 0</pre>


	<li>Run <code>make</code> in the top-level directory, using the same <code>make</code>
	executable used to build EPICS base.
	
	<blockquote>The build will issue a warning that it can't expand all macros
	in substitution files.  This is not an error; unexpanded macros are intended
	to be defined at boot time.  (Note that version 1-4 of <code>msi</code>
	returns an error, which causes the softGlue build to fail, after writing a
	database file that contains unexpanded macros.) </blockquote>

	</ul>

	<h3>Deploying softGlue to an IOC</h3>
	
	To configure an EPICS IOC application to use softGlue, you must make modifications in the
	following directories, and then rebuild the application:

		<ul>
		<li><code>configure/RELEASE</code>
			<P><ul>

			<li>Edit the <code>RELEASE</code> file to define the following names:
			<p><code>SOFTGLUE=&lt;path to the softGlue module&gt;<br>
			ASYN=&lt;path to the asyn module&gt;<br>
			IPAC=&lt;path to the ipac module&gt;<br>
			BUSY=&lt;path to the busy module&gt;<br>
			</code>

			<blockquote><code>BUSY</code> is an optional add-on for you to use with softGlue.  If
			the busy module is available, you can arrange for EPICS database processing to
			wait for a signal from softGlue hardware before declaring itself to be finished.  The
			<code>softGlue_convenience.db</code> database loads busy records for this purpose, and
			the <code>softGlueConvenience.adl</code> display file contains menu items to display the
			records.  Nothing else in softGlue depends on the busy module.</blockquote>


			</ul>
		<li><code>xxxApp/src</code>
			<P><ul>

			<li>Edit <code>Makefile</code> or a <code>*Include.dbd</code> file so that the file
				<code>softGlueSupport.dbd</code> is included in the <code>.dbd</code> file the
				IOC loads at boot time.  You'll also need files from asyn, ipac, and busy,
				if you're not already including them.<br>

				<P>For a Makefile:
				
				<pre>iocxxx_DBD_vxWorks += softGlueSupport.dbd drvIpac.dbd asyn.dbd busySupport.dbd</pre>

				For the .dbd file that will be loaded into a vxWorks IOC:

				<P><code>include "softGlueSupport.dbd"<br>
				include "drvIpac.dbd"<br>
				include "asyn.dbd"<br>
				include "busySupport.dbd"</code>

			<li>Edit <code>Makefile</code> so that the IOC executable is linked with the
				<code>softGlue</code> library. You'll also need libraries from the asyn, ipac,
				and busy  modules.  The order in which libraries are named is sometimes
				important.
				<P>Example:

				<pre>xxx_LIBS_vxWorks += asyn Ipac softGlue busy</pre>


			</ul>
		<li><code>iocBoot/ioc<em>xxx</em></code>
			<P><ul>

			<li>Copy <code>softGlue/iocBoot/iocSoftGlue/softGlue.cmd</code> to your IOC directory,
				which I'll call <code>iocBoot/ioc<em>xxx</em></code>, and edit the
				<code>dbLoadRecords()</code> commands in your copy of <code>softGlue.cmd</code> to
				define the macro <code>P</code>, so that it's unique to your IOC.

				<blockquote>If you'll have more than one IP_EP20x module in an IOC, you'll also need to
				maintain separate definitions for the macro, <code>H</code>, for asyn port names associated
				with the modules, and for the macro <code>READEVENT</code>.  Port names are supplied as
				arguments to the functions <code>initIP_EP200()</code>, <code>initIP_EP201(), and
				initIP_EP201SingleRegisterPort()</code>, and they are supplied as the macro definitions
				<code>PORT</code>, <code>PORT1</code>, <code>PORT2</code>, and <code>PORT3</code> in
				<code>dbLoadRecords()</code> commands.</blockquote>
				
				<blockquote>
				If you specify the same value of <code>READEVENT</code> for N instances of softGlue
				in a single IOC, the software will still work, but it will use N times the CPU cycles,
				as each instance will post read events that will cause all other instances to read
				from the hardware.
				</blockquote>

			<li>Add the following line to <code>st.cmd</code>, before the call to
				<code>iocInit()</code>.

				<pre>&lt; softGlue.cmd</pre>

			<li>If you use autosave:
				<P><ul>
				<li>Add the following line to <code>save_restore.cmd</code>:
				
					<P><code>set_requestfile_path(softglue, "softGlueApp/Db")</code>

					<blockquote><b>Careful</b>!  the first <code>softglue</code> must be all
					lowercase, because this is how the path variable is defined in
					<code>cdCommands</code>.
					</blockquote>

				<li>Add the following line to <code>auto_settings.req</code> (or whatever you've
					named the file used to save/restore PV's of arbitrary type):

					<P><code>file softGlue_settings.req  P=$(P) H=softGlue:</code>

					<P>where the macros <code>P</code>, and <code>H</code> agree with those in
					<code>softGlue.cmd</code>.
				</ul>

			</ul>
			<br>
		<li><code>xxxApp/op/adl</code>
			<P><ul>

			<li>If you use MEDM, add a related-display button to call up the
				<code>softGlueMenu.adl</code> display with the macros <code>P</code>, and 
				<code>H</code>, as defined in <code>iocBoot/ioc<em>xxx</em>/softGlue.cmd</code>. 
				The file <code>softGlueApp/op/adl/softGlueTop.adl</code> contains an example button.

				<blockquote>If you figure out how to use softGlue with some other display manager,
				please tell us about it, so we can include your work in the next version of
				softGlue.  The MEDM-display files included in softGlue make heavy use of
				MEDM's <code>composite file</code>, and I don't know the extent to which a
				comparable feature exists in other display managers.  softGlue's use of
				<code>composite file</code> is purely a display-development convenience.
				</blockquote>

			</ul>
		<li>If you use MEDM, give it access to the softGlue module's .adl files.  In csh, you
			could do this with the following command:

			<pre>setenv EPICS_DISPLAY_PATH $EPICS_DISPLAY_PATH':'$SOFTGLUE/softGlueApp/op/adl</pre>

		<li>Don't forget to rebuild you application:
			<pre>cd &lt;applicationTop&gt;</pre>
			<pre>make rebuild</pre>

		</ul>

	<h3>Configuring hardware</h3>

The IP-EP20x board must be configured to permit programming the FPGA via the
IndustryPack bus, by moving the DIP jumper to "IP BUS".  (This is the factory
default setting.)

	<h3>Configuring softGlue (editing softGlue.cmd)</h3>

<h4>User Callable Functions:</h4>
<ul>
<li>
<pre>
initIP_EP200_FPGA(ushort carrier, ushort slot, char *filename)
   carrier:  IP-carrier number (numbering begins at 0)
   slot:     IP-slot number (numbering begins at 0)
   filename: Name of the FPGA-content hex file to load into the FPGA.

Example:
   initIP_EP200_FPGA(0, 2, "$(SOFTGLUE)/softGlueApp/Db/SoftGlue_2_2.hex")

Write content to the FPGA.  This command will fail if the FPGA already has
content loaded, as it will after a soft reboot.  When the command fails for this
reason, the already loaded FPGA content will be left as it was, with no ill
effect.  To load new FPGA content, you must power cycle the ioc. </pre>

<li>
<pre>
int initIP_EP200(ushort carrier, ushort slot, char *portName1,
    char *portName2, char *portName3, int sopcBase)
    carrier:   IP-carrier number (numbering begins at 0)
    slot:      IP-slot number (numbering begins at 0)
    portName1: Name of asyn port for component at sopcBase
    portName2: Name of asyn port for component at sopcBase+0x10
    portName3: Name of asyn port for component at sopcBase+0x20
    sopcBase:  must agree with FPGA content (0x800000)

Example:
    initIP_EP200(0, 2, "SGIO_1", "SGIO_2", "SGIO_3", 0x800000)

Initialize basic field I/O 
</pre>

<li>
<pre>
int initIP_EP200_Int(ushort carrier, ushort slot, int intVectorBase,
        int risingMaskMS, int risingMaskLS, int fallingMaskMS,
        int fallingMaskLS)
    carrier:       IP-carrier number (numbering begins at 0)
    slot:          IP-slot number (numbering begins at 0)
    intVectorBase: must agree with the FPGA content loaded (0x90 for softGlue
                   2.1 and higher; 0x80 for softGlue 2.0 and lower).  softGlue
                   uses three vectors, for example, 0x90, 0x91, 0x92.
    risingMaskMS:  interrupt on 0->1 for I/O pins 33-48
    risingMaskLS:  interrupt on 0->1 for I/O pins 1-32
    fallingMaskMS: interrupt on 1->0 for I/O pins 33-48
    fallingMaskLS: interrupt on 1->0 for I/O pins 1-32

Example:
    initIP_EP200_Int(0, 2, 0x90, 0x0, 0x0, 0x0, 0x0)

Initialize field-I/O interrupt support
</pre>

<blockquote>

Note that interrupt vectors are hardwired in the supplied FPGA content.  Each
IP-EP20x module uses three vectors (0x90, 0x91, 0x92), one for each set of 16
I/O bits.  Depending on the interrupt-service mechanism supported by the
operating system, multiple IP-EP20x boards may or may not all be able to
generate interrupts.  For PowerPC processors, interrupt-service routines
(ISRs) are chained, so multiple IP-EP20x modules can all generate interrupts. 
But if the operating system doesn't permit multiple ISRs attached to a single
interrupt vector, then only one IP-EP20x board will be able to generate
interrupts.

<P>See "Field I/O Interrupt support", in the "User's Manual" section, for a
description of the <code>softGlueFieldIO_Intxx.adl</code> MEDM-display file by
which interrupt generation can be controlled by the end user.

</blockquote>

<li>
<pre>
int initIP_EP200_IO(ushort carrier, ushort slot, ushort moduleType,
        ushort dataDir)
    carrier:    IP-carrier number (numbering begins at 0)
    slot:       IP-slot number (numbering begins at 0)
    moduleType: one of [201, 202, 203, 204]
    dataDir:    Bit mask, in which only the first 9 bits are significant.  The
                meaning of each bit depends on moduleType, as shown in the
                table below.  If a bit is set, the corresponding field I/O pins
                are outputs.  Note that for the 202 and 204 modules, all I/O
                is differential, and I/O pin N is paired with pin N+1.  For the
                203 module, pins 25/26 through 47/48 are differential pairs.
</pre>
Correspondence between dataDir bits (0-8) and I/O pins (1-48)
<table border=true>
<tr><th>dataDir bit<th>201<th>202 or 204<th>203
<tr><td>bit 0 <td>pins 1-8<td>pins 1, 3,25,27<td>pins 25,27
<tr><td>bit 1 <td>pins 9-16<td>pins 5, 7,29,31<td>pins 29,31
<tr><td>bit 2 <td>pins 17-24<td>pins 9,11,33,35<td>pins 33,35
<tr><td>bit 3 <td>pins 25-32<td>pins 13,15,37,39<td>pins 37,39
<tr><td><td><td><td>
<tr><td>bit 4 <td>pins 33-40<td>pins 17,19,41,43<td>pins 41,43
<tr><td>bit 5 <td>pins 41-48<td>pins 21,23,45,47<td>pins 45,47
<tr><td>bit 6 <td>x<td>x<td>pins 1-8
<tr><td>bit 7 <td>x<td>x<td>pins 9-16
<tr><td><td><td><td>
<tr><td>bit 8 <td>x<td>x<td>pins 17-24
</table>

<pre>
    Examples:
    1. For the IP-EP201, moduleType is 201, and dataDir == 0x3c would mean
       that I/O bits 17-48 are outputs.
    2. For the IP-EP202 or IP-EP204, moduleType is 202 or 204, and dataDir == 0x13
       would mean that I/O bits 1,3,25,27, 5,7,29,31, 17,19,41,43 are outputs.
    3. For the IP-EP203, moduleType is 203, and dataDir == 0x??? would mean
       that I/O bits 1-8, 25,27, 29,31, 33,35, 45,47 are outputs.
</pre>

<P>Example:

<pre>
    initIP_EP200_IO(0, 2, 201, 0x3c)
</pre>

<P>Set field-I/O data direction

<li>
For backward compatibility with softGlue 2.1 and earlier, the following
command can be used to initialize an IP_EP201 module, instead of the
above calls to initIP_EP200(), initIP_EP200_Int(), and initIP_EP200_IO().
This won't work for any other IP_EP200-series module.
<pre>
int initIP_EP201(char *portName, ushort carrier, ushort slot,
        int msecPoll, int dataDir, int sopcOffset, int interruptVector,
        int risingMask, int fallingMask)
    portName: Name of asyn port for component at sopcOffset
    carrier:         IP-carrier number (numbering begins at 0)
    slot:            IP-slot number (numbering begins at 0)
    msecPoll:        Time interval between driver polls of field I/O bits
    dataDir:         Data direction for I/O bits, explained below.
    sopcOffset:      SOPC offset (must be as in example below).
    interruptVector: Must agree with the FPGA content loaded (0x90, 0x91,
                     0x92 for softGlue 2.1 and higher; 0x80, 0x81, 0x82 for
                     softGlue 2.0 and lower).
    risingMask:      16-bit mask: if a bit is 1, the corresponding I/O bit will
                     generate an interrupt when its value goes from 0 to 1.
                     Bit 0 corresponds to field I/O pin 1, bit 1 to pin 2, etc.
    fallingMask:     Similar to risingMask, but for 1-to-0 transitions.
    
                     Note that the user can overwrite risingMask and
                     fallingMask at run time, with menu selections, and
                     probably has those selections autosaved.

    dataDir is a bit mask in which only bits 0 and 8 are significant.
         for sopcOffset 0x800000
             If bit 0 of dataDir is set, I/O bits 1-8 are outputs.
             If bit 8 of dataDir is set, I/O bits 9-16 are outputs.
         for sopcOffset 0x800010
             If bit 0 of dataDir is set, I/O bits 17-24 are outputs.
             If bit 8 of dataDir is set, I/O bits 25-32 are outputs.
         for sopcOffset 0x800020
             If bit 0 of dataDir is set, I/O bits 33-40 are outputs.
             If bit 8 of dataDir is set, I/O bits 41-48 are outputs.

Example:
    initIP_EP201("SGIO_1",0,2,1000000,0x101,0x800000,0x90,0x00,0x00)
    initIP_EP201("SGIO_2",0,2,1000000,0x101,0x800010,0x91,0x00,0x00)
    initIP_EP201("SGIO_3",0,2,1000000,0x101,0x800020,0x92,0x00,0x00)
</pre>

<blockquote>

Note that interrupt vectors currently are hardwired in the supplied FPGA
content.  Thus, if you want to use two or more IP_EP20x modules, only one may be
permitted to generate interrupts.  Interrupt generation is entirely an end-user
choice, and it occurs only for the purpose of causing some EPICS record to
process on the change of state of a softGlue field I/O signal.  See "Field I/O
Interrupt support" below for a description of the
<code>softGlueFieldIO_Intxx.adl</code> MEDM-display file by which interrupt
generation is controlled.

</blockquote>

<li>
<pre>
initIP_EP201SingleRegisterPort(char *portName, ushort carrier, ushort slot)
</pre>

<P>Initialize softGlue signal-name support.

<P>Example:

<pre>
initIP_EP201SingleRegisterPort("SOFTGLUE", 0, 2)
</pre>

</ul>

<hr>
<a name="User's Manual"></a>
<h2><center>User's Manual</center></h2>

<P>Most of the essential user-interface information &mdash; how to connect signals, what the display
elements mean, etc. &mdash; is contained in the descriptions of the "User Menu" and "AND" sections
below.  The remaining sections are mostly for completeness, though some circuit elements do require
further explanation, and the counter sections introduce new display elements for registers
containing decimal numbers.

<P>We're going to have a little trouble with the meanings of "input" and "output", because they
imply a viewpoint, and because we're going to be taking three different viewpoints: those of EPICS
records, circuit elements, and field-wiring connectors.  Usually, in EPICS, we think of an output as
something to which an EPICS record can write, but that definition would be awkward here, because it
would eventually require us, for example, to refer to the output of an AND gate as an "input".  You
just can't discuss digital circuitry intelligibly from that viewpoint.

<P>Therefore, in this documentation, "input" and "output" will normally be from the viewpoint of one
of the circuit elements we'll be wiring.  Field I/O will be an exception, because it's most
conveniently discussed from the viewpoint of the field-wiring connector.


	<h3>MEDM user interface</h3>

<ul>

<hr>
<li><P>User Menu
<P><img src="Menu.gif" name="User Menu">

<P><code>softGlueMenu.adl</code> is the top softGlue display, which serves mostly to call up other
displays.  The menu labelled <code>READ PERIOD</code> specifies the period at which the values of
all signals are sampled for display to the user.


<blockquote>Most softGlue displays are not interrupt driven.  (That would be a disaster, because
inevitably some signals will change state at high frequency.)  So, the states of inputs and outputs
must be sampled periodically, for display to the user.

<P>We've found that it's confusing for users if the poll period is greater than
around 1 second.  We've also found that polling everything at .1 second uses only a few
percent of an MVME2700 CPU.</blockquote>

<hr>
<li><P>AND
<P><img src="AND.gif" name="AND">

<P> On the left of the AND gate are the inputs, each comprised of a blue "= button", a yellow
text-entry field, a number, and what's intended to look like a red LED.  On the right are
essentially the same things in reverse order, but an output's text-entry field is a different
color.  The text-entry fields are used to connect signals together, and the color difference is
intended to remind you of the only rule governing signal connections: if you connect two or more
outputs together, those outputs won't work.

<blockquote>softGlue outputs are engineered to ensure that you can't break anything by connecting
outputs together, but the circuit won't be useful until you fix the error, because the states of
outputs connected together are undefined.  Currently, softGlue doesn't signal this error by
putting offenders into an alarm state.</blockquote>

<P>The yellow text-entry box controls an input.  You have three options:
<ol>

<b><li>Leave empty.</b><br>

Inputs with empty text-entry boxes default to logic value 1.<P>

<b><li>Enter a string that begins with a number.</b><br>

This directly writes a logic value (optionally, a pulse) to the input.

<P>softGlue will parse everything that looks numberish, and convert to a floating point value.  This
sets the input to a logic value: 0 if the nearest integer to the converted value is zero, 1 if it's
not.

<blockquote>Allowing floats, and extra characters after the number makes it easier to drive softGlue
inputs with calcout records, replies from serial devices, etc.</blockquote>

<P>The strings "0!" and "1!" (possibly followed by other ignored characters) direct softGlue to
write a pair of logic values: "0!" writes "0" followed immediately by "1"; "1!" writes "1" followed
immediately by "0".  The time interval between writes is system dependent, and not at all
guaranteed, but it should be much smaller than the interval you could achieve from separate writes. 
On an MVME2700, I measure around 6 &mu;s.


<b><li>Enter a string that begins with something other than a number.</b><br>

This <em>names</em> the signal, and connects it to all other signals with the same name (or with the
same name followed by '<code>*</code>', as described below).  Case is significant in comparing
signal names.

<blockquote>Note that a "signal", as the word is used in this documentation, is a named connection
between softGlue circuit elements.  It might be more intuitive to think of a "signal" as a wire,
to avoid confusing it with, say, field I/O.</blockquote>

<blockquote>Note, if you're using more than one IP-EP20x module, that you can't connect signals implemented in
different IP-EP20x modules using their text-entry boxes. To accomplish this, you must connect the signals to
field I/O and make a physical connection.</blockquote>

</ol>

<P>If you want to use the inverted value of a signal for input to some component, append
'<code>*</code>' to the signal name.  This doesn't change the signal that the input is
connected to, but just tells softGlue to run the signal through an inverter before applying it
to the input.  Note that output signal names may not end with '<code>*</code>'.

<P>In MEDM, you can use Drag-And-Drop to connect a named signal to some other
signal.  When you drop, MEDM will put the PV name of the signal you dragged
from. When you press &lt;Enter&gt;, softGlue's device support will write the
signal name of the source PV to the destination PV.

<P>In caQtDM, you can select the text of a signal name, and use Copy/Paste
(^C/^V) to copy the signal name from one text-entry box to another.

</ol>

<P>Whatever option you choose, you can define at most fifteen different signal names. When you try
to define the 16th name, softGlue will erase whatever you wrote, and put the record into the
"INVALID" alarm state.  (But note, for example, that <code>reset</code> and <code>reset*</code> are
not different signal names, because the trailing '<code>*</code>' is not regarded as part of the
name; it merely describes how the signal should be used.)

<P>Text-entry boxes for output signals won't accept names beginning with a number, or ending with
'<code>*</code>'.  (softGlue will simply strip the offending characters, and leave the rest.)

<blockquote>A signal name beginning with a number can only be a direct-write command; it cannot connect
things together, because the leading number would be misinterpreted by input-signal-name parsing as a
direct-write command.  Output-signal names ending with '<code>*</code>' are logically sensible, but are
not permitted; this simplifies the implementation of '<code>*</code>' appended to input-signal names.
</blockquote>

<P>A signal's blue "= button" is used to find all other signals to which the signal is connected.
While a signal's "= button" is pressed, input signals connected to it are bordered in green, and output
signals connected to it are bordered in orange.  If you ever see two or more orange borders at
the same time, you have outputs connected together, and your circuit won't work.

<P>The little red and black filled circles (LED's), and the numbers next to them, display the states
of their signals.  These display elements are updated at the period specified in the
<code>softGlueMenu.adl</code> display.  If you want the EPICS PV name corresponding to a signal's
logic value, this is the PV name to use.

<P>For completeness, here's the truth table for an AND gate:
<P><table border>
<tr><th>input1<th>input2<th><th>output
<tr><td>0<td>x<td><td>0
<tr><td>x<td>0<td><td>0
<tr><td>1<td>1<td><td>1
</table>

<blockquote>'x' means "either 0 or 1".</blockquote>


<hr>
<li><P>OR
<P><img src="OR.gif" name="OR">

<P><table border>
<tr><th>input1<th>input2<th><th>output
<tr><td>0<td>0<td><td>0
<tr><td>1<td>x<td><td>1
<tr><td>x<td>1<td><td>1
</table>

<hr>
<li><P>BUFFER
<P><img src="BUFFER.gif" name="BUFFER">

<P>The purpose of the buffer element is to permit EPICS to drive several softGlue inputs
by writing to a single PV, without using up a more valuable circuit element, such as the XOR gate below.

<hr>
<li><P>INVERTING BUFFER
<P><img src="INVERTING_BUFFER.gif" name="BUFFER">

<P>There is no inverting buffer - or any other inverting gate - in softGlue.  Signal inversion is
accomplished by appending '*' to the name of a signal used as as input to any logic element, as
demonstrated above for the buffer element.  Note that '*' appended to the name of an output
signal will be removed.

<hr>
<li><P>XOR
<P><img src="XOR.gif" name="XOR">

<P><table border>
<tr><th>input1<th>input2<th><th>output
<tr><td>0<td>0<td><td>0
<tr><td>0<td>1<td><td>1
<tr><td>1<td>0<td><td>1
<tr><td>1<td>1<td><td>0
</table>

<hr>
<li><P>D FlipFlop
<P><img src="DFF.gif" name="D FlipFlop">

<P>The input signal labelled "&gt;" is the "clock" input.  Unlike other signals, clock inputs are
edge sensitive.  All clock inputs in softGlue act on the rising edge of the input signal.

<P>The open circle ("bubble") in the <code>SET</code> and <code>CLEAR</code> inputs' signal paths indicate
that these signals are inverted before being used.  Thus, applying '0' to the <code>CLEAR</code> input causes
the output to be "cleared" (given the value 0).

<P><table border>
<tr><th>SET<th>CLEAR<th>D<th>&gt; (clock)<th><th>Q
<tr><td>0  <td>0    <td>x<td>x   <td><td>undefined
<tr><td>0  <td>1    <td>x<td>x   <td><td>1
<tr><td>1  <td>0    <td>x<td>x   <td><td>0
<tr><td>1  <td>1    <td>any<td>rising edge<td><td>D<sub>BEFORE</sub> (value D had immediately before the rising edge of the clock signal)
</table>

<hr>
<li><P>2-Input Multiplexer
<P><img src="MUX2.gif" name="2-Input Multiplexer">

<P>When <code>SEL==0</code>, <code>OUT=IN0</code>.  When <code>SEL==1</code>, <code>OUT=IN1</code>.

<hr>
<li><P>2-Output Demultiplexer
<P><img src="DEMUX2.gif" name="2-Output Demultiplexer">

<P>When <code>SEL==0</code>, <code>OUT0=IN</code>, and <code>OUT1</code> is undefined (currently
0).  When <code>SEL==1</code>, <code>OUT1=IN</code>, and <code>OUT0</code> is undefined (currently
0).

<hr>
<li><P>Up Counter (32-bit Counter)
<P><img src="UpCntr.gif" name="32-bit Counter">

<P><code>EN==1</code> enables the clock ("&gt;") input, whose rising edge increments the counter value.

<hr>
<li><P>Down Counter (32-bit Preset Counter)
<P><img src="DnCntr.gif" name="16-bit Preset Counter">

<P><code>EN==1</code> enables the clock (">") input, whose rising edge decrements the counter value. 
When <code>LOAD==1</code> the counter is loaded with the value applied to the <code>PRESET</code>
input.  While <code>LOAD==1</code>, the counter does not count down.  While <code>LOAD==0</code> and
<code>EN==1</code>, a rising edge at the clock input decrements the counter.  When the counter value
reaches <code>0</code>, the output <code>Q</code> goes to <code>1</code>; the next rising edge of the
clock returns <code>Q</code> to <code>0</code> (regardless of the states of <code>EN</code> and
<code>LOAD</code>).

<hr>
<li><P>32-bit Divide By N
<P><img src="DivByN.gif" name="Divide By N">

<P><code>EN==1</code> enables the clock (">") input.  Every <code>N</code>'th
rising edge of the clock drives <code>Q</code> to <code>1</code>.  The next
rising edge returns <code>Q</code> to <code>0</code>.    This behavior produces the correct number of rising edges of
the output signal, but it does not guarantee the same number of falling edges.
Therefore, using an inverted copy of the output to clock downstream electronics
will in some cases have inconsistent results.

When <code>N</code>==<code>0</code>, the divide circuitry is bypassed, and the
clock is connected directly to <code>Q</code>.  This is an error; the output
should still be gated by the <code>EN</code> signal.

<P>In softGlue version 2.1 and earlier, the <code>RESET</code> signal doesn't do
anything.  Beginning with softGlue 2.2, the <code>RESET</code> signal loads the
counter with <code>N</code>, so that <code>Q</code> will be driven to
<code>1</code> after <code>N</code> rising edges of the clock. 
<code>RESET</code> does not clear the output <code>Q</code>.  If <code>Q</code>
is <code>1</code>, it will be cleared on the first rising edge of the clock.

<P>

<hr>
<li><P>8 MHz internal clock
<P><img src="8MHz_clock.gif" name="* MHz clock">

<P>An 8 MHz clock derived from the IndustryPack clock is available to softGlue
circuitry as a free standing output.

<hr>
<li><P>Field I/O
<P><img src="Field_IO.gif" name="Field I/O">

<P>This display allows you to connect field I/O signals to each other and to softGlue circuits. 
Note that a "Field Input Bit" looks like and behaves as a softGlue <em>output</em>, because what
you're actually controlling is the output of a buffer driven by the field-input signal.  Similarly,
a "Field Output Bit" looks like and behaves as a softGlue <em>input</em>, because you're actually
controlling the input of a buffer that drives the field-output signal.


<P>The signals in this display are the field inputs or outputs connected to pins 1-16, 17-32, or 33-48
on the IP-EP201's ribbon connector.  The IP-EP201 board supports 48 I/O bits, and permits them to be set
for input or output in groups of 8.

<P>"POLL TIME (MS)" specifies the period at which softGlue reads the I/O ports
for user-display purposes, and for executing the EPICS link associated with 
non-interrupt-enabled I/O bits (see next section).  If an I/O bit has changed
value since the last read, softGlue processes the display record associated with
that bit, so the user will see the new value. If an I/O bit is enabled to
generate interrupts, as described in the next section, the bit will be read
immediately by the interrupt handler, so "POLL TIME" will not matter for that
bit.

<P>Note: If you have a field input connected to an FPGA component, the component
will react to a change in the input value within nanoseconds.  I/O polling is
not involved at all in the logic connection.

<blockquote>You can change the "CONNECTOR&nbsp;#" strings in this display
&mdash; for example, to support a custom signal-breakout module, or to give the
I/O signals application-specific names.  The strings are defined in
<code>softGlueApp/Db/softGlue_FPGAContent.substitutions</code>, as the macro
<code>IOPIN</code> supplied to <code>softGlue_FieldOutput.db</code> and
<code>softGlue_FieldInput.db</code>.  In softGlue 2.3.1, field I/O displays
leave room for longer strings, and there is a an autosave-request file for
these PVs.</blockquote>

<P>During a VME power cycle, and during a VME reset, field outputs are first put into a high
impedance state, then are driven to ground, and finally are driven to values controlled by the user
circuit.  If user-circuit field-outputs are autosaved, they will be restored during the boot;
otherwise, they will default to logic 1 (+5V for TTL).

<P>During a soft reboot (that is, when the vxWorks "reboot" command is given in the ioc console),
field outputs will maintain their values.


<hr>
<li><P>Field I/O Interrupt support
<P><img src="Field_IO_Int.gif" name="Field I/O">

<P>Field-input lines supported by softGlue can generate interrupts on rising edges,
falling edges, both, or neither.  You control this by setting the "INTERRUPT&nbsp;ENABLE"
menu to "Rising", "Falling", "Both", or "None", respectively.  Field output lines can also
generate interrupts: if a bit is designated as an output, the output is connected also to
the input, and to the input's interrupt-generation circuitry.

<P>Interrupts are throttled by softGlue's interrupt handler.  If more than four interrupts have
occurred and not been handled, softGlue will disable interrupts from the offending bit, by setting
the bit's "INTERRUPT&nbsp;ENABLE" menu to "None", and it will direct your attention to the change by
drawing a red box around the menu control.  The box will be erased the next time the menu is written
to.

<blockquote>The number of unhandled interrupts that triggers throttling is adjustable by modifying
drvIP_EP201.c.  You must change the definition of <code>MAX_IRQ</code>, and you must also ensure
that the asyn ring buffers for interrupt driven PV's is larger than <code>MAX_IRQ</code>. (The
default ring buffer size is 10.  Asyn documentation describes how to change it.) </blockquote>

<P>When an interrupt occurs, you can have the signal value written to an EPICS PV, by writing an
EPICS link description into the purple box labelled "ON INTERRUPT, WRITE SIGNAL VALUE VIA THIS
LINK", as shown for input 16 in the above screen shot.

<P><i>For interrupts that may occur too closely spaced in time for softGlue's normal
interrupt-response mechanism to handle reliably, see "Custom Interrupt Handlers", below.</i>

<h4>About EPICS links</h4>

<P>In softGlue displays (and in most other synApps displays), standard EPICS links are displayed as
purple text-entry boxes, in which you describe the link you want to make.  For purposes here, an
EPICS link description is the name of an EPICS PV, followed by one of the following link attributes:

<P><table border>

<tr><td>NPP<td>(default) write value, but do not cause processing.

<tr><td>PP<td>write value and cause processing (if the record containing the PV is "Process
Passive", which means that it's SCAN field has the value "Passive").<br>
You should use this attribute unless you have some reason not to use it.

<tr><td>CA<td>write value and let the record containing the PV decide whether or not to process.

</table>

<blockquote>EPICS will tack on the string " NMS".  This alarm-propagation attribute is not something
end users need to worry about. </blockquote>

<P>For example, to cause a link to write effectively to the top input of the first AND gate
(whose PV name is  <code>xxx:softGlue:AND-1_IN1_Signal</code>, you would write the following
into a purple box:

<pre>xxx:softGlue:AND-1_IN1_Signal PP</pre>

If you only write the PV name, EPICS will supply the link attribute <code>NPP</code>, and your link
will write a value, but the value won't have any effect until the next time the record processes.
(For most PV's in softGlue, the value written by an NPP link won't even be displayed until the
record processes.)

<P><b>Note:</b> if the link writes to a PV in a different IOC, the specified link
attribute will be ignored, and the attribute "CA" will be used instead.

<hr>

<li><P>Everything on one display, with the signal named "clock" highlighted so that all of its connections
are evident.  A signal name gets this treatment when the "= button" next to an input or output is
pressed.  Note that connections to inputs are bordered in green, and connections to outputs are bordered
in orange.

<P><img src="AllBlink.gif" name="All">

<P>This display shows everything in softGlue except interrupt support.

<hr>
<li><P>Convenience
<P><img src="Convenience.gif" name="Convenience">

<P>This display controls two pulse generators implemented in EPICS, with links allowing them to
write to a softGlue input (that is, to a yellow box), and, similarly, two clock generators
implemented in EPICS.  The display also has MEDM related-display callups for two busy records,

<blockquote>The use of EPICS links (the purple boxes in the above display) is described above in
the section "About EPICS links", in the documentation of "Field I/O Interrupt support".</blockquote>

<hr>
<li><P>BusyRecord
<P><img src="BusyRecord.gif" name="Busy Record">

<P>This display controls the value, output link, and forward link of a busy record.  In the
anticipated use with softGlue, one would have some EPICS record outside of softGlue set the busy
record to "Busy" (using a PP link), and arrange for a softGlue interrupt bit (see "Field I/O
Interrupt support", above) to use its EPICS-output link to clear the busy record to "Done" (using a
CA link).

<blockquote>The use of EPICS links (the purple boxes in the above display) is described above in
the section "About EPICS links", in the documentation of "Field I/O Interrupt support".</blockquote>

<blockquote> It's important to <b>set</b> a busy record to "Busy" using a PP link, because the
purpose of a busy record is to represent some external processing as EPICS processing.  This allows
EPICS' execution tracing to signal the completion of the processing.  EPICS only traces processing
started or propagated with a PP link.

<P>It's important to <b>clear</b> a busy record to "Done" with a CA link, because an EPICS PP link
will decline to process any record that is already processing. The busy record is written so that a
CA put will succeed in clearing it and causing its processing to appear done to EPICS.</blockquote>

</ul>
<hr>

<a name="Add-on FPGA components"></a>
<h2><center>Add-on FPGA components</center></h2>

The following components are not in the standard softGlue package, but in
add-on packages typically made to solve specific problems.

<ul>

<li><P>32-bit Up/Down Counter
<P><img src="UpDnCntr.gif" name="Up/Down Counter">

<P><code>EN==1</code> enables the clock (">") input.  <code>CLEAR==1</code> sets
the current count and the output value <code>Q</code> to zero.  When
<code>UP/DOWN==1</code> the counter counts up.  <code>LOAD</code> sets the
current count to <code>PRESET</code>

<P>
<hr>

<li><P>Quadrature Decoder
<P><img src="QuadDec.gif" name="Quadrature Decoder">

<P>This circuit converts a pair of digital quadrature signals <code>A, B</code>
(for example, signals from an encoder) into a pair of <code>STEP, DIR</code>
signals.  <code>A</code> and <code>B</code> are samples on rising edges of the
<code>CLOCK</code> signal.  If either have changed since the last rising edge,
the travel direction implied by the change is output to <code>DIR</code>, and a
pulse is output to <code>STEP</code>.  The pulse width is equal to the period of
the <code>CLOCK</code> signal, and the input frequency may not be greater than
half the clock frequency.

<P>
<hr>

<li><P>Shift Register
<P><img src="ShiftReg.gif" name="Shift Register">

<P>This circuit converts from parallel to serial, or from serial to parallel.

<P>For parallel-to-serial conversion, a number is written into the
<code>LOADVAL</code> register, and loaded by a positive-going pulse to the
<code>LOAD</code> input.  On each rising edge of the clock input
<code>&gt;</code>, the loaded value is shifted toward the most significant bit,
and the most significant bit is output to the <ocde>Q</code> output.

<P>For serial-to-parallel conversion, the input <code>D</code> is sampled on the
rising edge of the clock input, and that value is shifted into the least
significant bit of the register.

<P>

<li><P>Four-output demultiplexer
<P><img src="softGlue4DEMUX4.gif" name="Four-output demultiplexer">

<P> When SEL0==0 and SEL1==0, OUT0=IN, and other OUTs are undefined (currently 0).<br>
When SEL0==1 and SEL1==0, OUT1=IN, and other OUTs are undefined (currently 0).<br>
When SEL0==0 and SEL1==1, OUT2=IN, and other OUTs are undefined (currently 0).<br>
When SEL0==1 and SEL1==1, OUT3=IN, and other OUTs are undefined (currently 0).<br>

<P> There are two copies of this add-on component:
<ol>

<li>SoftGlue_2_2_demux4.hex - the basic component, with all inputs and outputs
routed to signal names, as usual for softGlue.

<li>SoftGlue_2_2_demux4_HW.hex - the same component, but with multiplexer
outputs routed to signal names, as usual, and also hardwired to the last 16
field I/O pins. Thus, DEMUX4-1_OUT0 is connected to pin 33, DEMUX4-1_OUT1 is
connected to pin 34, ..., and DEMUX4-4_OUT3 is connected to pin 48.

</ol>

<li><P>Encoder Time Average circuit
<P><img src="encoderTimeAverage.gif" name="Encoder Time Average circuit">

<P>This circuit is for general encoder support, and also for generating a time
averaged value of an encoder signal.  Up/Down counters 1-4 are copies of the
32-bit Up/Down counter described above.  Up/Down counter 5 is also a 32-bit
Up/Down counter, but it has no "Q" output.  Instead, it has "Q8" and "C8"
outputs.  Q8 is true whenever the 8 least significant bits are all zero.  C8 is
a ripple carry bit, which allows the eight lsbits of this counter to be combined
with any 32-bit counter to make a 40-bit counter. 

<P>MagCmp-1 is a 32-bit magnitude comparator, which produces the signals "A>B"
and "A!=B" on the rising edge of the clock "SAMPLE".  The component also
produces the signals "BCLOCK" and "BDIR" with the following circuitry, which
uses the "Q8" signal from Up/Down counter 5:

<P><img src="softGlue_MagCmp_help.gif" name="softGlue_MagCmp_help.adl">

</ul>

<hr>

<a name="Saving and restoring circuits"></a>
<h2><center>Saving and restoring circuits</center></h2>
	
	softGlue circuits can be saved and restored using <a
	href="http://www.aps.anl.gov/bcda/synApps/autosave/autosave.html">autosave</a>,
	autosave's <i>configMenu</i> facility, <a
	href="http://www.aps.anl.gov/epics/extensions/burt/index.php">BURT</a>, or
	any channel access client that can read and write PV's.  configMenu is
	particularly handy, because it's driven by EPICS PVs, and because it saves a
	time-stamped backup copy of every file it overwrites.

	<P>Whichever method you use, you may need to clear softGlue signal names
	before loading a circuit, because loading over an existing circuit could
	temporarily exceed the available number of signal names.  (Alternatively,
	you could simply load twice, and be confident that the second load will
	succeed.)

	<h4>Saving and restoring circuits with autosave's configMenu facility</h4>

	<P><img src="configMenu.gif" name="configMenu">

	<P>If you have autosave R5-1 or higher, you can use configMenu to save and
	restore circuits.  Here are the steps needed to implement a menu of softGlue
	circuits, and to give the user a GUI display for saving and restoring them. 
	(In the following, <font color="blue">SG</font> is the name of this instance
	of configMenu.  The files it loads and saves will be named "<font
	color="blue">SG</font>_&lt;<i>config Name</i>&gt;.cfg".  For examples, the
	configMenu instance pictured above has files named "<font
	color="blue">SG</font>_clear.cfg", "<font
	color="blue">SG</font>_encoderTest.cfg", etc..)

	<blockquote> <ol> <li>In the IOC's startup directory, create an autosave
	request file, which I'll call "<font color="blue">SG</font>Menu.req", with
	the following content:

	<P><code>
	file configMenu.req P=$(P),CONFIG=$(CONFIG)<br>
	file softGlue_settings.req  P=$(P),H=$(H)
	</code>

	<P><li>Uncomment the following line in the IOC's copy of
	<code>softGlue.cmd</code>:

	<P><code>dbLoadRecords("$(AUTOSAVE)/asApp/Db/configMenu.db","P=xxx:,CONFIG=<font color="blue">SG</font>")</code>

	<li>Add the following line to <code>st.cmd</code>:

	<P><code>create_manual_set("<font color="blue">SG</font>Menu.req","P=xxx:,CONFIG=<font color="blue">SG</font>")</code>

	<li>Add an MEDM related-display entry to bring up the configMenu.adl display.

	<P><code>
	label="SGMenu"<br>
	name="configMenu.adl"<br>
	args="P=xxx:,CONFIG=<font color="blue">SG</font>"
	</code>

	</ol>
	</blockquote>

	<P>softGlue includes configMenu files (*.cfg) for standard example circuits
	in the iocBoot/iocSoftGlue directory.  In actual use, these .cfg files would
	be placed in your application's iocBoot/iocxxx/autosave directory.  For more
	information on configMenu, see the autosave documentation.

	<h4>Saving and restoring circuits with BURT</h4>
	
	The BURT request file <code>softGlueApp/op/burt/softGlue.snap</code> can be
	used to save all softGlue user modifiable PV's.  For example, the following
	command saves the state of softGlue to the file <code>myCircuit.snap</code>.

	<pre>burtrb -f softGlue.req -DPREFIX=xxx:softGlue -o myCircuit.snap</pre>

	<blockquote>
	<dl>
	<dt> "<code>-f softGlue.req</code>"
	<dd>specifies that the request file <code>softGlue.req</code> should be
	used to specify the EPICS PVs whose values are to be saved.   This file
	contains lines like this: "<code>PREFIX:AND-1_IN1_Signal</code>", where
	"<code>PREFIX</code>" is to be replaced by text specific to your ioc.
	<dt>"<code>-DPREFIX=xxx:softGlue</code>"
	<dd>specifies that <code>PREFIX</code>
	is to be replaced by <code>xxx:softGlue</code>.
	<dt>"<code>-o myCircuit.snap</code>"
	<dd>specifies that the saved PV names and values are to be written to the
	snapshot file "<code>myCircuit.snap</code>".
	</dl>
	No doubt your PREFIX will be different from mine, but it should
	be <code>$(P)$(H)</code> from your copy of <code>softGlue.cmd</code>,
	minus the trailing ':' from $(H).  BURT needs the ':' to separate "PREFIX"
	from the rest of the PV names it parses.  If you defined H without a
	trailing ':', you'll need to make some adjustment to satisfy BURT.
	</blockquote>

	<P>The following commands restore the circuit:
	
	<pre>burtwb -f clearAll.snap</pre>
	<pre>burtwb -f myCircuit.snap</pre>

	<P>The first command is often needed because there is a limit to the number
	of signal names that softGlue will accept.  If you neglect to clear all
	signals before restoring a circuit, the allowed number of signal names might
	be exceeded during the restore, if new signal names are defined before old
	signal names are deleted.  (Alternatively, you could simply run the second
	command twice.)

	<P>To restore example circuits included in the softGlue module, or to
	restore a snapshot file emailed to you by some other softGlue user, you will
	need to edit the snapshot file to change PV names such as
	"<code><b>xxx</b>:softGlue:AND-1_IN2_Signal</code>" to PV names in your ioc, which
	might look like  "<code><b>1ida</b>:softGlue:AND-1_IN2_Signal</code>".
	

<hr>
<a name="Example circuits"></a>
<h2><center>Example circuits</center></h2>

<P>The following circuits have been tested and saved in BURT snapshot files, and
as configMenu .cfg files,  as described above (see <i>Saving and Restoring
Circuits</i>).  The snapshot files can be found in
<code>softGlueApp/op/burt</code>; the .cfg files are in iocBoot/iocSoftGlue.

		<ol>
		<li><h4>Motor-pulse gate </h4>

		Positive-going pulses can be gated with an AND gate, by applying the signal to one input of the AND gate,
		and setting the other input to 0(1) to deny(allow) passage through the gate.

		<P>Negative-going pulses can be gated with an OR gate, by applying the signal to one input
		of the OR gate, and setting the other input to 0(1) to allow(deny) passage through the
		gate.

		<li><h4>Gated scaler</h4> <P><i>Files:
			<code>softGlueApp/op/burt/gatedScaler.snap or 
			iocBoot/iocSoftGlue/gatedScaler.cfg</code></i>

		<P>This circuit implements four counter channels, a time base to control
		counting time, an overall gate, and additional circuitry to control
		starting,  stopping, and processing of the count-value records.  Note
		that the scaler is controlled by a busy record from the softGlue
		convenience database, so that client software can discover when counting
		is finished in the standard EPICS way.  See
		<code>softGlueApp/op/burt/gatedScaler.txt</code> for more details.


		<P><img src="gatedScaler.gif" name="gatedScaler">

		<li><h4>Four independent start-time/stop-time pulses</h4>
		<P><i>File: <code>softGlueApp/op/burt/fourPulses.snap or 
		iocBoot/iocSoftGlue/fourPulses.cfg</code></i>

		<P>This circuit produces four separate pulse signals, which start at
		specified start-delay times after (the falling edge of) an initial start
		pulse, and which last for specified pulse-length times.  It uses four
		DnCntr's to implement the start-delay times, and four DivByN's to
		implement the pulse-length times.  Times are specified as multiples of
		the (125 ns) clock period (<code>PRESET</code> for the DnCntr's;
		<code>N</code> for the DivByN's), and these numbers must be greater than
		or equal to 1.  The pulse sequence starts on the falling edge of the
		signal <code>BUF-1</code>, written by a periodically scanned EPICS
		record (one of the softGlue convenience clocks).  One spare signal name
		is available, however, so the pulse sequence could also be started by an
		external signal.

		<P><img src="fourPulses.gif" name="fourPulses">

		<li><h4>Motor-pulse accel/decel gate</h4>
		
		<P><i>Files: <code>softGlueApp/op/burt/accelDecelGate.snap or
		iocBoot/iocSoftGlue/accelDecelGate.cfg</code></i>  <br>
	
		(Non-softGlue support in
		<code>softGlueApp/op/burt/accelDecelGate_transform.sav</code>.)

		<P>If you know the number of steps a stepper motor will move during its acceleration time, you
		can easily arrange to deliver motor pulses to some external circuit only while the motor is
		moving at constant speed.  For a stepper motor controlled by the motor record, the number of
		acceleration/deceleration steps, <code>N<sub>a</sub></code>, can be calculated with the following
		formula:

		<ul>
		<p><code>N<sub>a</sub> = ((VBAS+VELO)/2)*ACCL/MRES</code>
		</ul>

		<P>where, <code>VBAS</code>, <code>VELO</code>, <code>ACCL</code>, and <code>MRES</code> are
		motorRecord fields.
		
		<P>The number of constant-speed steps, <code>N<sub>c</sub></code>, is then

		<ul>
		<P><code>N<sub>c</sub> = ((VAL<sub>end</sub> - VAL<sub>start</sub>)/MRES) -
		2*N<sub>a</sub></code>
		</ul>

		<P>where <code>VAL<sub>end</sub></code> and <code>VAL<sub>start</sub></code> are the final
		and initial values of the motorRecord <code>VAL</code> field.

		<P>The following circuit accepts negative-going motor pulses at input signal 1, gates out
		the first 11 (the value of <code>DnCntr-1_PRESET</code>), and from then on sends motor
		pulses to output pin 17 until a total of 31 (the value of <code>DnCntr-2_PRESET</code>) have
		been sent.  The circuit is reset by writing "1!" (positive-going pulse) to the input of BUF-1.

		<P>The circuit includes some diagnostics, and a mechanism for testing:
			<ul>

			<li><code>UpCntr-1</code> counts all motor pulses; <code>UpCntr-2</code> counts gated
			motor pulses.  Both counters are reset by the same signal that resets the gate circuit.

			<li>A manual reset is implemented using BUF-1.  Writing "1!" to the input of BUF-1,
			as shown, causes a short positive-going pulse to be applied to it, and thus to its output,
			the signal named "reset".

		<P><img src="accelDecelGate.gif" name="accelDecelGate">

		<P>Down counter <code>DnCntr-1</code>, and flipflop <code>DFF-1</code>, together produce a gate
		signal that is 0 after a reset, and that goes to 1 after <code>DnCntr-1_PRESET</code> motor
		pulses.  Down counter <code>DnCntr-2</code>, and flipflop <code>DFF-2</code>, together produce a
		gate signal that is 1 after a reset, and that goes to 0 after <code>DnCntr-2_PRESET</code> motor
		pulses.  We load the number of acceleration steps into <code>DnCntr-1_PRESET</code>, and the
		number of acceleration steps plus constant-speed steps into <code>DnCntr-2_PRESET</code>.

		<P><code>AND-1</code> combines the gate signals produced above into a signal that is 1 while
		the motor is moving at constant speed.

		<P><code>AND-2</code> gates the negative-going motor pulses, using what
		was described in the "Motor-pulse gate" example as a
		positive-going-pulse gate, by inverting the "motor" signal before
		applying it to the gate.

		<P>Note that the down counters are clocked by (rising edges of) "motor", to produce the
		signal used to gate "motor<code>*</code>".  This choice avoids a race condition between simultaneous
		rising edges of "gateOut" and "motor".  (This circuit gates negative-going motor pulses, so
		another way to make the point is to say that the trailing edge of a motor pulse is used to
		produce a gate that will be ready in plenty of time for the leading edge of the next motor
		pulse.)

		<P>Calculations for the circuit are shown in the following screen capture of a transform
		record.

		<P><img src="accelDecelGateCalc.gif" name="accelDecelGateCalc">
		</ol>

<P>For more softGlue-circuit examples, see
<a
href="https://subversion.xray.aps.anl.gov/admin_bcdaext/softGlue_examples">https://subversion.xray.aps.anl.gov/admin_bcdaext/softGlue_examples</a>
Currently, the following circuits are documented:
<ul>
<li>Programmable pulse train
<li>Gated scaler
<li>Pulse burst
<li>Delay generator
<li>Motor accel/decel pulse gate
<li>Debouncer
</ul>


<hr>
<a name="Field wiring"></a>
<h2><center>Field wiring</center></h2>

<h3>IP-EP201 (TTL)</h3>

<P>Getting clean electrical signals from the IP-EP201 out to field wiring
requires some attention to detail.  The signals have short rise times (on the
order of a few ns), and the IP-EP201 pinout places 48 of them on adjacent
ribbon-cable conductors, with a single ground conductor at one end of the
ribbon.  This combination pretty much guarantees problems with crosstalk and
ringing.

<P>Firstly, sharp-edged signals produce significant crosstalk between
conductors, because the magnetic fields generated by signal currents vary
rapidly enough during changes of state to induce significant voltages in nearby
conductors. There is also the possibility of crosstalk from the fact that return
currents of all signals share a single ground conductor.  The shared-ground 
contribution is small, compared to the magnetic-field-induced contribution, but
it could be significant in long (tens of feet) ribbon cables.

<P>Secondly, sharp-edged signals require transmission-line termination to damp
reflections at impedance mismatches.  Otherwise downstream electronics will see
ringing, as current sloshes back and forth through the cable, which can (if it
exceeds the TTL noise margin) make each transition look like two or more. But the
IP-EP201 has no termination, and its pinout results in 48 coupled transmissions
lines, for which effective termination is probably not possible.

<P>Nevertheless, it's possible to get clean signals to field wiring using the
following strategy:

<ol>

<li>Interface the single 50-pin ribbon header to two 50-conductor twisted-pair
cables, so that each signal is paired with a ground line, and all ground lines
are connected to pin 50.  The characteristic impedance of this configuration is
around 100 Ohms for most ribbon cables.

<li>Terminate each output signal with a series resistor whose value matches the
characteristic impedance.

</ol>

Series termination does three very nice things for us:
<ol>

<li>It permits the IP-EP201 outputs to drive the transmission line.  The
IP-EP201 outputs can only sink or source 24 mA -- not enough to drive a 50-Ohm
load to TTL levels, so parallel termination (100-Ohm resistors to ground at each
end of the ribbon) would require a buffer.  Even a single 100-Ohm termination
resistor to ground would reduce the noise margin considerably.

<li>It damps reflections returned from the cable end.  (This only works for
outputs, which are low impedance.  Inputs are high impedance, and series
termination cannot reduce the impedance.)

<li>It acts as a low-pass filter to soften the signal edges, effectively
reducing magnetic crosstalk to values well below the TTL noise margin.

</ol>

<P>The APS BCDA group has produced three circuit boards that implement this
strategy:

<ul>
<li>BC-020 - Multi purpose IP to Lemo interface (DIN-rail)
<li>BC-091 - Daughter board for BC-020
<li>BC-092 - Ribbon-cable adapter
</ul>

See the <a
href="http://www.aps.anl.gov/bcda/hardware/custom_hw/bcda_hw_all.php">BCDA
Custom Hardware</a> web page for more information.  The boards are connected
together as in the diagram below.  

<P><img src="fieldWiring.png" name="fieldWiring.png">

<P>The BC-092 plugs directly into the IP carrier's 50-pin ribbon connector. 
(Take care: the connector is not polarized.  It's your job to plug it in the
right way.)  A ribbon cable goes from the BC-092 to the <code>H1</code> ribbon
header on the BC-020 board.  (The <code>H2</code> header is not used for
softGlue.)  The BC-091 daughter board is plugged into the BC-020, and the I/O
direction is set, for groups of eight bits, with DIP jumpers on the BC-091.

<P><img src="colorLine.gif" name="colorLine.gif">

<P><img src="020_IPLemoInterface.jpg" name="020_IPLemoInterface.jpg">
<P>The BC-020 LEMO interface.  With the EP-201 board, only the first 24 LEMO
connectors are used.  The BC-091 daughter board is plugged into the white
headers at the center of the board.
<P><img src="colorLine.gif" name="colorLine.gif">

<P><img src="BC-091_EP201_Buffer_Lemo.jpg" name="BC-091_EP201_Buffer_Lemo.jpg">
<P> A BC-020 board with the BC-091 daughter board installed.  Note the DIP
jumpers near the center of the daughter board.  With this setting, I/O pins
1-16 are inputs (jumper on), and pins 17-24 are outputs.
<P><img src="colorLine.gif" name="colorLine.gif">

<P><img src="BC-092_EP201_Header.jpg" name="BC-092_EP201_Header.jpg">

<P>Closeup of the BC-092 board, with SIP resistor packs installed.  Normally,
100-Ohm resistors are used, because this is the nominal impedance of many ribbon
cables.  Although the terminating resistors are useful only for outputs, they
are usually installed for all I/O pins.
<P><img src="colorLine.gif" name="colorLine.gif">

<P><img src="BC092_connect_front.jpg" name="BC092_connect_front.jpg">
<P>Closeup showing how to connect the BC-092 to the TEWS TVME-200 IP carrier.
<P><img src="colorLine.gif" name="colorLine.gif">

<P><img src="BC092_connect_back.jpg" name="BC092_connect_back.jpg">

<P>Closeup of the other side of the BC-092 board.  The ribbon connector closest
to the IP carrier (the <code>J2</code> connector) handles I/O pins 1-24.
<P><img src="colorLine.gif" name="colorLine.gif">

<h3>IP-EP202 (RS-485/422)</h3>

<P>This section not yet written.

<h3>IP-EP241 (lvds)</h3>

<P>This section not yet written.

<hr>
<a name="Custom Interrupt Handlers"></a>
<h2><center>Custom Interrupt Handlers</center></h2>

softGlue's normal interrupt-response mechanism allows you to specify the execution of an EPICS
output link, which will write to and possibly process a specified EPICS record, whenever an
enabled interrupt occurs.  This mechanism is unreliable for interrupts that are spaced in time by
less than a few milliseconds, because the EPICS processing is dispatched through message queues,
and requires several task switches before the target record gets processed.

<P>For interrupts that may occur more closly spaced in time, you can write a custom
interrupt-handler routine, and tell softGlue to call it at interrupt level whenever an enabled
interrupt occurs.  There is an example in the softGlueApp/src directory: 
sampleCustomInterruptHandler.c, which handles the following application requirement:

<blockquote>When an enabled interrupt occurs on a specified bit of a specified IP_EP20x board,
read a number from an array, write that number to the <code>N</code> register of a specified
softGlue DivByN component on that same IP_EP20x board, and increment the array index for the
next read.</blockquote>

<P>sampleCustomInterruptHandler.c contains two functions:
<dl>

<dt><code>sampleCustomInterruptPrepare()</code>

<dd>This function gathers some information for use by
<code>sampleCustomInterruptRoutine()</code>, and tells softGlue to call
<code>sampleCustomInterruptRoutine()</code> from its interrupt-service routine when a specified
interrupt occurs.  The interrupt is specified by <code>carrier</code> and <code>slot</code>,
which specify the IP_EP20x board; <code>sopcAddress</code>, which specifies the address of one of
three I/O registers on the board; and <code>mask</code>, which specifies one or more bits of the
specified I/O register.

<dt><code>sampleCustomInterruptRoutine()</code>

<dd>This function executes at interrupt level, reads a number from an array, writes that number
to the <code>N</code> register whose VME addresses were calculated by
<code>sampleCustomInterruptPrepare()</code>, and increments the array index.

</dl>

<P>Other files in softGlueApp/src that help implement sampleCustomInterruptHandler are
<code>Makefile</code>, which builds it, and <code>softGlueSupport.dbd</code>, which
contains the line <code>registrar(sampleCustomInterruptRegistrar)</code>.


<hr>
<a name="Implementation"></a>
<h2><center>Implementation</center></h2>

	<h3>FPGA-content files</h3>

	This version of softGlue contains four FPGA-content files, only one of which can be loaded at a
time.

<P><dl>
<dt>SoftGlue_2_2.hex
<dd>This file contains all standard softGlue components.

<dt>SoftGlue_2_2_0_Octupole_0_0.hex
<dd>This file contains everything in SoftGlue_2_2.hex, plus two 32-bit shift registers.

<dt>SoftGlue_2_2_Encoder.hex
<dd>This file contains everything in SoftGlue_2_2.hex, plus two 32-bit up/down
counters, plus two quadrature decoders.

<dt>SoftGlue_2_2_encoder_ave.hex

<dd>This file contains everything in SoftGlue_2_2.hex, plus four 32-bit up/down
counters, two quadrature decoders, one 32-bit magnitude comparator that is
hardwired to compare counters 1 and 2, and one eight-bit up/down counter.

<dt>SoftGlue_2_2_1ID_Vgate_0_1.hex
<dd>This file contains everything in SoftGlue_2_2.hex, plus two 32-bit up/down
counters.


</dl>

	<h3>Database files</h3>

<dl>

<dt>softGlue_FPGAContent.substitutions

<dd>This substitutions file is run through <code>msi</code> at build time to
produce the database file <code>softGlue_FPGAContent.db</code>.  The database
file loads records matching most of the FPGA content that is loaded at cold-boot
time from <code>SoftGlue_2_2.hex</code>.<P>

<dt>softGlue_FPGAContent_octupole.substitutions

<dd>This substitutions file is run through <code>msi</code> at build time to produce the database file
<code>softGlue_FPGAContent_octupole.db</code>.  The database file loads records for the two 32-bit
shift registers in <code>SoftGlue_2_2_Octupole_0_0.hex</code>.<P>

<dt>softGlue_FPGAContent_Encoder.substitutions

<dd>This substitutions file is run through <code>msi</code> at build time to
produce the database file <code>softGlue_FPGAContent_Encoder.db</code>.  The
database file loads records for the two 32-bit up/down counters in
<code>SoftGlue_2_2_Encoder.hex</code>.<P>

<dt>softGlue_FPGAContent_EncoderAvg.substitutions

<dd>This substitutions file is run through <code>msi</code> at build time to
produce the database file <code>softGlue_FPGAContent_EncoderAvg.db</code>.  The
database file loads records for the additional content in
<code>SoftGlue_2_2_encoder_ave.hex</code>.<P>

<dt>softGlue_FPGAContent_s1ID_Vgate.substitutions

<dd>This substitutions file is run through <code>msi</code> at build time to
produce the database file <code>softGlue_FPGAContent_s1ID_Vgate.db</code>.  The
database file loads records for the two 32-bit up/down counters in
<code>SoftGlue_2_2_1ID_Vgate_0_1.hex</code>.<P>

<dt>softGlue_FPGAInt.substitutions

<dd>This substitutions file is run through <code>msi</code> at build time to
produce the database file <code>softGlue_FPGAInt.db</code>.  The database file
loads records matching the field-I/O register components loaded into the FPGA.
These components control the field I/O registers which softGlue uses to connect
with external wiring.  The file also loads records by which the user can control
the period at which the driver's poller thread wakes up to read any I/O bits
that have not been enabled to generate interrupts.<P>

<dt>softGlue_Input.db<br>
softGlue_Output.db

<dd>These databases each support a single softGlue circuit-element I/O bit.<P>

<dt>softGlue_FieldInput.db<br>
softGlue_FieldOutput.db

<dd>These databases each support a single field I/O bit.<P>

<dt> softGlue_InRegister.db

<dd>This database supports reads from a 16-bit register.  (Currently, no
softGlue circuit element uses this database.)<P>

<dt>softGlue_InRegister32.db

<dd>This database supports reads from a 32-bit register, implemented in the FPGA as two 16-bit
registers.<P>

<dt>softGlue_IntBit.db

<dd>This database supports a single input bit, with an interrupt-driven bi record to read the bit
value, and a forward linked bo record to write that value to some user specified EPICS PV.<P>

<dt>softGlue_IntEdge.db

<dd>This database controls the interrupt-enable mask for a single input bit.<P>


<dt>softGlue_PollTime.db

<dd>This database controls the polling period for a field I/O register set.  This period is
the rate at which I/O bits that do not generate interrupts are read.<P>

<dt>softGlue_Register.db

<dd>This database supports writes to a 16-bit register.  (Currently, no
softGlue circuit element uses this database.)<P>

<dt>softGlue_Register32.db

<dd>This database supports writes to a 32-bit register, such as the "N" value for a divide-by-N
circuit element.<P>

<dt>softGlue_SignalShow.db

<dd>This database implements part of softGlue's mechanism for showing users which signals are
connected together.  When a user presses a signal's "= button", the signal's name is written to a PV
in this database, against which PV all softGlue signals compare their own signal names, to determine
whether or not to display their "connected" boxes.<P>

<dt>softGlue_convenience.db

<dd>This database contains two busy records by which softGlue can signal completion to EPICS, two
software pulse generators, and two software clock generators.<P>

<dt>softGlue_FPGAContentDev.substitutions<br>
softGlue_FPGAIntDev.substitutions

<dd>These files are not used in a standard deployment of softGlue, but are provided for developers
and deployers of custom FPGA-content.  They are essentially the same as
softGlue_FPGAContent.substitutions, and softGlue_FPGAInt.substitutions, but are intended to be used
directly in dbLoadTemplate() commands, rather than run through <code>msi</code> to produce partially
resolved databases loaded by dbLoadRecords().<P>

</dl>



	<h3>Autosave-request files</h3>

<dl>
<dt>softGlue_FPGAContent_settings.req<br>
softGlue_FPGAContent_octupole_settings.req<br>
softGlue_FPGAContent_Encoder_settings.req<br>
softGlue_FPGAContent_s1ID_Vgate_settings.req<br>
softGlue_FPGAInt_settings.req<br>
softGlue_SignalShow_settings.req<br>
softGlue_convenience_settings.req<br>

<dd>These autosave request files correspond with similarly named database or
substitutions files, and take the same macro definitions.<P>

<dt>softGlue_settings.req

<dd>This autosave-request file <i>includes</i> softGlue_SignalShow_settings.req,
softGlue_FPGAContent_settings.req, softGlue_FPGAInt_settings.req, and
softGlue_convenience_settings.req.  For standard softGlue, this is the only
autosave-request file an IOC needs.<P>

</dl>

	<h3>Display files (MEDM, CSS-BOY, and caQtDM)</h3>

	There are too many display files to describe individually, and many are
	similar, so I'll just describe classes of display files, and the overall
	implementation strategy.  Displays whose names begin with "softGlue_"
	support individual circuit elements.  Displays whose names are of the form
	"softGlueXxx" (no underscore after "softGlue") support collections of
	circuit elements, either by implementing menus for calling up other
	displays, or by including several "softGlue_" displays.  ("Include", in this
	context, means specified as a "Composite File", with macro arguments, in the
	definition of an MEDM grouped item, or specified as a "linkgroup" in
	CSS-BOY.)

	<P>In the rest of this display-file documentation, I'll give MEDM examples.
	For CSS-BOY examples, just substitute ".opi" for ".adl".  For caQtDM,
	substitute ".ui".

	<P>The display of a softGlue circuit element is built in layers, from
	instances of softGlue_Input.adl and softGlue_Output.adl, which are
	<i>included</i> in softGlue_&lt;element name&gt;_bare.adl, which in turn is
	included in one of the user displays (for example, softGlueAll.adl,
	softGlue_AND.adl, etc.).

	<P><dl>
	<dt>softGlueMenu.adl<br>
	softGlueTop.adl

	<dd><code>softGlueMenu.adl</code> contains related-display menus for everything in softGlue.
	<code>softGlueTop.adl</code> is an example of how <code>softGlueMenu.adl</code> can be called up.

	<dt>softGlue_Input.adl<br>
	softGlue_Output.adl
	
	<dd>These displays support a <i>single 16-bit register component</i> (see "Driver", below) in the
	FPGA, and most softGlue circuit-element displays include several instances of these displays.  For
	example, softGlue_AND_bare.adl includes two instances of softGlue_Input.adl, and one instance of
	softGlue_Output.adl.

	<dt>softGlue_*.adl<br>
	softGlue_*_bare.adl, where * is one of AND, BUFFER, DEMUX2, DFF, DivByN, DnCntr, MUX2, MUX4, OR, Shift32, UpCntr, XOR

	<dd>These files each support a single circuit element, such as an AND gate.  The "_bare.adl"
	displays are intended to be included in some other display.

	<dt>softGlue_Field*.adl<br>
	softGlue_Field*_bare.adl, where * is one of FieldInput, FieldOutput, IntBit.    The "_bare.adl"
	displays are intended to be included in some other display.

	<dd>These files support a single field-I/O bit, or the interrupt control and dispatch records
	associated with a field-I/O bit.

	</dl>

	<h3>Driver</h3>
	
	<P>softGlue's driver implements four asyn ports to connect EPICS records with registers
	implemented in the IP-EP20x module's FPGA.  Three ports connect with "fieldIO_registerSet"
	components, which provide comprehensive control over digital I/O bits implemented in the module,
	including data direction (i.e., read or write), interrupt enable, and status.  The fourth asyn
	port connects with "single 16-bit register" components, with which all softGlue signal
	connections are implemented.

		<P>The following is copied from drvIP-EP201.c:

		<pre>
    This driver cooperates with specific FPGA firmware loaded into the Acromag
    IP-EP201 (and probably other IP-EP200-series modules).  The loaded FPGA
    firmware includes Eric Norum's IndustryPack Bridge, which is an interface
    between the IndustryPack bus and the Altera FPGA's Avalon bus.  The
    IndustryPack Bridge does not define anything we can write to in the FPGA. 
    It's job is to support additional firmware loaded into the FPGA.  The
    additional firmware defines registers that we can read and write, and it can
    take one of the two forms (sopc components) supported by this driver:

        1) fieldIO_registerSet component

           A set of seven 16-bit registers defined by 'fieldIO_registerSet'
           below.  This register set provides bit-level I/O direction and
           interrupt-generation support, and is intended primarily to
           implement field I/O registers.

        2) single 16-bit register component

           a single 16-bit register, which has no interrupt service or bit-level
           I/O direction.  This type of sopc component is just a plain 16-bit
           register, which can be written to or read.  This driver doesn't know
           or care what the register might be connected to inside the FPGA.

    Each fieldIO_registerSet component must be initialized by a separate call to
    initIP_EP201(), because the component's sopc address must be specified at
    init time, so that the interrupt-service routine associated with the
    component can use the sopc address.  Currently, each call to initIP_EP201()
    defines a new asyn port, connects an interrupt-service routine, creates a
    message queue, and launches a thread.

    Single 16-bit register components, on the other hand, need not have their
    sopc addresses known at init time, because they are not associated with an
    interrupt service routine.  As a consequence, many such single-register
    components can be served by a single asyn port.  Users of this port must
    specify the sopc address of the register they want to read or write in
    their asynUser structure. Records do this by including the address in the
    definition of the record's OUT or INP field.  For example, the ADDR macro in
    the following field definition should be set to the register's sopc address:
    field(OUT,"@asynMask($(PORT),$(ADDR),0x2f)")

    The addressing of sopc components requires some explanation.  When a
    component is loaded into the FPGA, it is given an sopc address, which is a
    number in one of two regions of the Avalon address space.  These regions of
    Avalon memory space are mapped by the IndustryPack Bridge to specific ranges
    of the IndustryPack module's IO and MEM spaces.  The IO and MEM spaces, in
    turn, are mapped by the IndustryPack carrier, and by the ipac-module
    software, to corresponding ranges in a VME address space.  The lowest
    address in the IndustryPack module's IO space is mapped to the VME A16
    address given by ipmBaseAddr(carrier, slot, ipac_addrIO), which I'll call
    IOBASE in the following table.  The lowest address in the IndustryPack
    module's MEM space is mapped to the VME A32 address given by
    ipmBaseAddr(carrier, slot, ipac_addrMem), which I'll call MEMBASE in the
    following table.  (The module's MEM space could also have been mapped to the
    VME A24 space.  This code doesn't know or care, because it just gets the VME
    address by making a function call to code provided by the ipac module.)
    
    Note that IOBASE and MEMBASE depend on the IndustryPack carrier and slot
    into which the IP-EP200 module has been placed.

    Avalon_address | IP_space  IP_address  | VME_space   VME_address
    (sopc address) |                       |                 
    ---------------|-----------------------|-----------------------------
    0x000000       | IO        0x000000    | A16         IOBASE+0x000000     
    ...            | IO        ...         | A16         ...             
    0x00007f       | IO        0x00007f    | A16         IOBASE+0x00007f     
                   |                       |                                        
    0x800000       | MEM       0x000000    | A32         MEMBASE+0x000000
    ...            | MEM       ...         | A32         ...
    0xffffff       | MEM       0x7fffff    | A32         MEMBASE+0x7fffff
    
    Thus, if a component is created with the sopc address 0x000010, it can be
    accessed at the IO-space address 0x000010, which is mapped to the VME
    address IOBASE+0x000010.  If a component is created with the sopc address
    0x800003, it can be accessed at MEM-space address 0x000003, which is
    mapped to the VME address MEMBASE+0x000003.

    Note that users of this code are not expected to know anything about this
    address-mapping business.  The only address users ever specify is the sopc
    address, exactly as it was specified to Quartus.

		</pre>

	<h3>Device support</h3> <P>softGlue uses standard asyn device support for everything except
		signal names, which are handled by devAsynSoftGlue.c.  The driver supports asynInt32 and
		asynUInt32Digital interfaces; devAsynSoftGlue.c uses asynUInt32Digital.

		<P>devAsynSoftGlue.c maintains lists of signal names and associates each signal name with
		one of 15 bus lines implemented in the FPGA.  When a new signal name is encountered, it is
		assigned to an unused bus line (or ignored if there are no unused bus lines). The bus line
		number is written to a register, in the FPGA, which controls a multiplexer (for input
		signals) or demultiplexer (for output signals).
		
		<P>If an input signal name ends with '<code>*</code>', a register bit is set that causes the
		output of the multiplexer to be routed through an inverter before being connected to the
		circuit element.  If an input signal is numeric, it is assigned to multiplexer address 0,
		which is driven not by a bus line, but by a register bit set according to the numeric value.
		(If '<code>*</code>' is appended to a numeric signal, it's ignored.)

	<h3>Field I/O</h3>
		<P> Field inputs and outputs are supported by two independent sets of binary input and
		output records:

		<dl>

		<dt>softGlue-supported records

		<dd>These records are part of a database that also includes
		signal-wiring fields (the <code>softGlue_FPGAContent.db</code>
		database); they are connected to hardware via softGlue's asyn port (the
		port initialized by the function
		<code>initIP_EP201SingleRegisterPort()</code>), and no interrupt support
		is provided for them.  They are polled at a rate determined by the
		<code>READ PERIOD</code> menu on the <code>softGlueMenu.adl</code>
		display.

		<dt>non-softGlue-supported records

		<dd>These records are loaded separately from the records described
		above (they are loaded by the <code>softGlue_FPGAInt.db</code> database); they
		are connected to hardware via the asyn port initialized by the function
		<code>initIP_EP201()</code>, and they can be interrupt driven.  They are also
		polled periodically.  The polling period's initial value is specified as an
		argument to <code>initIP_EP201()</code>, and it can be modified by the user
		via the <code>POLL TIME (MS)</code> text entry on
		<code>softGlueFieldIO*.adl</code> displays.
		</dl>

	<h3>FPGA content</h3>

<h4>IndustryPack bus interface</h4>
All communication between EPICS and the FPGA goes through Eric Norum's IP-bus interface,
which is described in <a href="IndustryPackBridge.html">IndustryPackBridge.html</a>.

<h4> Single-register component</h4>

Most of softGlue is implemented with single-register FPGA components connecting to standard
digital circuitry, such as AND gates, counters, etc., through interface circuitry of the
following three types:

<P><dl>

<dt>Input

<dd>An input is essentially a 16-input multiplexer controlled by a register that softGlue
can write to and read from.  Inputs 1-15 of all input multiplexers are connected together to form a
15-line bus, so that all inputs with the same multiplexer address are connected together.

<P>Input 0 of the multiplexer is special: it connects to the "U" bit of the signal's control
register, instead of to a bus line, and is the means by which softGlue implements direct user
control of the signal value.  When the user writes "0" or "1" as a signal name, softGlue sets the
multiplexer address to zero, and sets the "U" bit to 0 or 1.

<P>A second register bit, "N", controls whether or not the multiplexer output is routed through an
inverter before connecting to the payload digital circuit element input; this bit is the means by
which softGlue implements names like "reset*", which connects the input to an inverted copy of the
signal, "reset".  The invert bit could be, but currently is not, used with the "U" bit.

<P><table border>
<tr><td>bit:<td>15<td>14<td>13<td>12<td>11<td>10<td>&nbsp;9<td>&nbsp;8<td>&nbsp;7<td>&nbsp;6<td>&nbsp;5<td>&nbsp;4<td>&nbsp;3<td>&nbsp;2<td>&nbsp;1<td>&nbsp;0
<tr><td>function:<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>N<td>R<td>U<td>A<sub>3</sub><td>A<sub>2</sub><td>A<sub>1</sub><td>A<sub>0</sub>
</table>

<P>where
<P><table border>
<tr><td>N<td>invert-signal bit
<tr><td>R<td>read bit
<tr><td>U<td>user-write bit
<tr><td>A<sub>n</sub><td>bus-line address bit
</table>

<dt>Output

<dd>An output is a signal routed via a demultiplexer to any of 15 bus lines.  No connection is made
to the demultiplexer output selected by the address 0; this address is used to implement unconnected
output signals.

<P><table border>
<tr><td>bit:<td>15<td>14<td>13<td>12<td>11<td>10<td>&nbsp;9<td>&nbsp;8<td>&nbsp;7<td>&nbsp;6<td>&nbsp;5<td>&nbsp;4<td>&nbsp;3<td>&nbsp;2<td>&nbsp;1<td>&nbsp;0
<tr><td>function:<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>R<td>&nbsp;&nbsp;<td>A<sub>3</sub><td>A<sub>2</sub><td>A<sub>1</sub><td>A<sub>0</sub>
</table>
<P>where R and A<sub>n</sub> are as defined above for the input register.

<dt>16-bit register<dd>integer value written by EPICS to a parameter register with a fixed connection
to a specific device instance.  softGlue uses two 16-bit registers to implement the 32-bit
up counter.


</dl>

<h4> Field I/O register set component ("IP_EP20x") </h4>


This SOPC component supports 16 bits of field I/O
<h5> Registers </h5>

<table border>
<tr><th>Address Offset<th>Function<th>Description<th>Read/Write
<tr><td>0<td>Control/Status<td>Field-I/O direction, IRQ status<td>Read/Write
<tr><td>1<td>Field I/O Write Data OR Diff/Dir register<td>Write Field I/O or differential/direction register, depending on the FPGA content and how "DIFF_DIR" is defined in drvIP_EP201.c<td>Read/Write
<tr><td>2<td>Field I/O Read Data<td>Read Field I/O ONLY when dir = 0<td>Read
<tr><td>3<td>Rising IRQ Status Bits<td>Which Bits are causing interrupt from field I/O on transition to 1<td>Read/Write*
<tr><td>4<td>Rising IRQ Interrupt-Enable Bits<td>Which Rising edge bits have IRQ Enabled<td>Read/Write
<tr><td>5<td>Falling IRQ Status Bits<td>Which bits are causing interrupt from field I/O on transition to 0<td>Read/Write*
<tr><td>6<td>Falling IRQ Interrupt-enable bits<td>Which bits have falling IRQ enabled<td>Read/Write
<tr><td colspan=4>* A write to this register clears interrupts for nonzero bits.  For example, after servicing
a rising-edge interrupt from bit 0, the interrupt-service routine writes 0x01 to register 3 before re-enabling interrupts.
</table>

<h5> Control/Status-register bits </h5>
<table border>
<tr><th>Bit<th>Function<th>Value<th>Description
<tr><td>0<td>Field I/O Direction Lower 8-Bits<td>0=Input, 1=Output<td>Sets I/O direction for the lower 8 field-I/O bits (single-ended signals only)
<tr><td>1<td>&nbsp<td>0<td>&nbsp
<tr><td>2<td>&nbsp<td>0<td>&nbsp
<tr><td>3<td>&nbsp<td>0<td>&nbsp
<tr><td>4<td>&nbsp<td>0<td>&nbsp
<tr><td>5<td>Falling Edge IRQ Present<td>1=Present<td>Falling Edge interrupt from bits 0-7 sets bit to 1
<tr><td>6<td>Rising Edge IRQ Present<td>1=Present<td>Rising Edge interrupt from bits 0-7 sets bit to 1
<tr><td>7<td>Lower 8-bits IRQ Present<td>1=Present<td>Interrupt from bits 0-7 sets bit to 1
<tr><td>8<td>Field I/O Direction Upper 8-Bits<td>0=Input, 1=Output<td>Sets I/O direction for the upper 8 field-I/O bits (single-ended signals only)
<tr><td>9<td>&nbsp<td>0<td>&nbsp
<tr><td>10<td>&nbsp<td>0<td>&nbsp
<tr><td>11<td>&nbsp<td>0<td>&nbsp
<tr><td>12<td>&nbsp<td>0<td>&nbsp
<tr><td>13<td>Falling Edge IRQ Present Upper 8-Bits<td>1=Present<td>Falling Edge interrupt from bits 8-15 sets bit to 1
<tr><td>14<td>Rising Edge IRQ Present  Upper 8-Bits<td>1=Present<td>Rising Edge interrupt from bits 8-15 sets bit to 1
<tr><td>15<td>Upper 8-bits IRQ Present<td>1=Present<td>Interrupt from bits 8-15 sets bit to 1
</table>

<h5> Diff/Dir-register bits </h5>
<table border>
<tr><th>Bit<th>Function<th>Value<th>Description
<tr><td>0<td>Field I/O Direction Bit 0<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>1<td>Field I/O Direction Bit 1<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>2<td>Field I/O Direction Bit 2<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>3<td>Field I/O Direction Bit 3<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>4<td>Field I/O Direction Bit 4<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>5<td>Field I/O Direction Bit 5<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>6<td>Differential<td>1=lower eight bits represent four differential signals<td>See Diff/Dir note below
<tr><td>7<td>Differential<td>1=upper eight bits represent four differential signals<td>See Diff/Dir note below
<tr><td>8<td>&nbsp<td>0<td>&nbsp
<tr><td>9<td>&nbsp<td>0<td>&nbsp
<tr><td>10<td>&nbsp<td>0<td>&nbsp
<tr><td>11<td>&nbsp<td>0<td>&nbsp
<tr><td>12<td>&nbsp<td>0<td>&nbsp
<tr><td>13<td>&nbsp<td>0<td>&nbsp
<tr><td>14<td>&nbsp<td>0<td>&nbsp
<tr><td>15<td>&nbsp<td>0<td>&nbsp
</table>

	<h4>Diff/Dir note</h4>

Field-I/O data direction for IP_EP200-series modules is awkward and unfortunate, and is different for the different module
types.  The module types differ in which I/O bits are single ended and which are differential.  Bit numbering can be a little
confusing in this context, because two single ended signals from one module type use the same pins as a single differential
signal from another module type.  In this documentation, I'll just talk about field I/O connector pins, which are numbered
1-48, and which are the same for all module types.

<P><dl>
<dt>IP_EP201<dd>pins 1-48 are single ended.
<dt>IP_EP202 & IP_EP204<dd>pins 1-48 are differential.  The software acts like it's driving only odd
numbered pins, because the even numbered pins are their differential pairs.
<dt>IP_EP203<dd>pins 1-24 are single ended, pins 25-48 are differential.  For differential pins, the
software acts like it's driving only odd numbered pins, because the even numbered pins are their
differential pairs.
</dl>

<P>For single ended pins, data direction is controlled by the Control/Status register of a "Field I/O register set" component. 
Each component controls 16 I/O pins.  Bit 0 of Control/Status controls the direction of the lower eight I/O pins, bit 8
controls the direction of the upper eight pins.

<P>For differential pins, data direction is controlled by bits 0-5 of the Diff/Dir register of the first (lowest SOPC address)
"Field I/O register set" component.

<P>FPGA content must be told which pins are single ended and which are differential.  Bits 6-7 of the Diff/Dir register of a
"Field I/O register set" component are used for this purpose.  If bit 6 is 1, the lower eight I/O pins are differential.  If
bit 7 is 1, the upper eight I/O pins are differential.  

	<h3>Miscellaneous notes</h3>

The following notes have not been integrated into the documentation yet.
They are included for completeness.

<pre>



------------------------------------------------------------------------------
Deployment considerations

We need to ensure that the software agrees with the FPGA programming.  Software
dependence on FPGA content is of three kinds:

1) Dependence on the register set with which SOPC components are implemented. There are two
   different register sets currently in use: Marty Smith's original register set (called
   'fieldIO_registerSet' in comments within drvIP_EP201.c), and Kurt Goetze's register set (called
   'single 16-bit register' &mdash; a misnomer, because there are several registers in the component, but
   thus far only one register is used.) This dependence is restricted to the driver code,
   drvIP_EP201.c.

2) Dependence on the user circuits attached to 'single 16-bit register' SOPC components.  For
   example, the version 2.0 implementation of softGlue has several AND gates, several OR
   gates, some counters, etc., controlled by 'single 16-bit register' components.

   This dependence is restricted to the database, autosave-request file, and MEDM displays, which
   should have an analog for each 'single 16-bit register' component, and which should know which
   component address corresponds with which user circuit, and with which part of the user circuit.
   For example, the inverting output of AND gate #1 is associated by address with a 'single
   16-bit register' component.

3) Dependence on field I/O direction settings.  In softGlue 2.x, field I/O direction is not
adjustable by the user, but is fixed at boot time.  All databases and MEDM-display files are
compatible with any choice of field I/O direction settings, though MEDM displays don't give
the user any information about which bits are inputs and which are outputs.

Currently, the only strategy in use for ensuring that EPICS support agrees with FPGA content is the
inclusion of FPGA content with softGlue.  Deployers are expected to copy files from
softGlue/iocBoot/iocSoftGlue for initial deployment, and to copy them again for any version
upgrades, or else to take responsibility themselves for agreement between software and firmware.

------------------------------------------------------------------------------
Programming the FPGA via the IP bus.

The IP-EP20x board has to be prepared for this by moving the DIP jumper to
"IP BUS".  (This is the factory default setting.)

The hex file to be loaded is included in the softGlueApp/Db directory.
It was prepared as follows, in Quartus, according to an email from Marty Smith:

1. Under programming type select the Hexadecimal file format for Intel
2. Select your file name
3. Add your .sof file
4. Select the sof file and hit the properties button
5. Select the compression box
6. Make sure that you have selected 1-bit Passive Serial above for the mode
7. Select the options button under programming file type
    make sure that you have a start address of 0x0 and that the count up
    radio button is selected
8. Generate your file
</pre>


<hr>

<h3>Credits</h3>

The essential enabling work underlying softGlue is Eric Norum's <a
href="IndustryPackBridge.html">IndustryPack Bridge</a>.  David Kline engineered
a proof-of-principle implementation, working from another of Eric's
bus-interface solutions, for a non-VME architecture.  Marty Smith wrote a driver
to talk to custom FPGA content interfaced to Eric's IndustryPack Bridge.  Kurt
Goetze and Marty Smith implemented the FPGA content included with softGlue, and
Tim Mooney extended Marty's driver and wrote the EPICS application.

<hr>
<ADDRESS STYLE="text-align: left">Suggestions and Comments to: <br>
<A HREF="mailto:mooney@aps.anl.gov">
Tim Mooney </A>: (mooney@aps.anl.gov) 
</ADDRESS>
</BODY>
</HTML>
